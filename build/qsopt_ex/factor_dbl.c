/* WARNING! This file was autogenerated from template */
/****************************************************************************/
/*                                                                          */
/*  This file is part of QSopt_ex.                                          */
/*                                                                          */
/*  (c) Copyright 2006 by David Applegate, William Cook, Sanjeeb Dash,      */
/*  and Daniel Espinoza                                                     */
/*                                                                          */
/*  Sanjeeb Dash ownership of copyright in QSopt_ex is derived from his     */
/*  copyright in QSopt.                                                     */
/*                                                                          */
/*  This code may be used under the terms of the GNU General Public License */
/*  (Version 2.1 or later) as published by the Free Software Foundation.    */
/*                                                                          */
/*  Alternatively, use is granted for research purposes only.               */
/*                                                                          */
/*  It is your choice of which of these two licenses you are operating      */
/*  under.                                                                  */
/*                                                                          */
/*  We make no guarantees about the correctness or usefulness of this code. */
/*                                                                          */
/****************************************************************************/

/* RCS_INFO = "$RCSfile: factor.c,v $ $Revision: 1.2 $ $Date: 2003/11/05 16:49:52 $"; */
//static int TRACE = 0;

/* implement a = max(a,abs(b)) and execute the extra code if the update is
 * needed */
#define EGlpNumSetToMaxAbsAndDo(a,b,c) \
	if(dbl_EGlpNumIsGreatZero(b))\
	{\
		if(dbl_EGlpNumIsLess(a,b)){\
			dbl_EGlpNumCopy(a,b);\
			c;\
			}\
	}\
	else\
	{\
		dbl_EGlpNumSign(a);\
		if(dbl_EGlpNumIsLess(b,a)){\
			dbl_EGlpNumCopy(a,b);\
			c;\
			}\
		dbl_EGlpNumSign(a);\
	}

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "logging-private.h"

#include "allocrus.h"
#include "eg_lpnum.h"
#include "eg_numutil_dbl.h"
#include "eg_io.h"
#include "except.h"
#include "util.h"

#include "lpdefs_dbl.h"
#include "factor_dbl.h"


#undef  RECORD
#undef  DEBUG_FACTOR
#undef  SOLVE_DEBUG

#undef  FACTOR_DEBUG
#undef  UPDATE_DEBUG

#undef TRACK_FACTOR
#undef NOTICE_BLOWUP

#undef  FACTOR_STATS
#undef  UPDATE_STATS
#undef  GROWTH_STATS

#undef  UPDATE_STUDY

#undef  SORT_RESULTS

#ifdef UPDATE_STUDY
int nupdate = 0;
long int colspiketot = 0.0;
long int rowspiketot = 0.0;
long int permshifttot = 0.0;
long int leftetatot = 0.0;
#endif

void dbl_ILLfactor_init_factor_work (
	dbl_factor_work * f)
{
	f->max_k = 1000;							/* must be less than 46340 (2^15.5) */
	dbl_EGlpNumCopy (f->fzero_tol, dbl_SZERO_TOLER);	/* 2^-50 */
	dbl_EGlpNumCopy (f->szero_tol, dbl_SZERO_TOLER);	/* 2^-50 */
	dbl_EGlpNumCopy (f->partial_tol, dbl_OBJBND_TOLER);	/* 2^-7 */
	f->ur_space_mul = 2.0;
	f->uc_space_mul = 1.1;
	f->lc_space_mul = 1.1;
	f->er_space_mul = 1000.0;
	f->grow_mul = 1.5;
	f->p = 4;
	f->etamax = 100;
	f->minmult = 1e3;
	f->maxmult = 1e5;
	f->updmaxmult = 1e7;
	f->dense_fract = 0.25;
	f->dense_min = 25;
	dbl_EGlpNumCopy (f->partial_cur, f->partial_tol);
	f->work_coef = 0;
	f->work_indx = 0;
	f->uc_inf = 0;
	f->ur_inf = 0;
	f->lc_inf = 0;
	f->lr_inf = 0;
	f->er_inf = 0;
	f->ucindx = 0;
	f->ucrind = 0;
	f->uccoef = 0;
	f->urindx = 0;
	f->urcind = 0;
	f->urcoef = 0;
	f->lcindx = 0;
	f->lccoef = 0;
	f->lrindx = 0;
	f->lrcoef = 0;
	f->erindx = 0;
	f->ercoef = 0;
	f->rperm = 0;
	f->rrank = 0;
	f->cperm = 0;
	f->crank = 0;
	f->dmat = 0;
	dbl_ILLsvector_init (&f->xtmp);
}

void dbl_ILLfactor_free_factor_work (
	dbl_factor_work * f)
{
#ifdef UPDATE_STUDY
	if (nupdate)
	{
		MESSAGE(0, "UPDATE STUDY: avg %d upd: %.2f col, %.2f row, %.2f lefteta, "
						"%.2f perm", nupdate, ((double) colspiketot) / nupdate, 
						((double) rowspiketot) / nupdate, ((double) leftetatot) / nupdate,
						((double) permshifttot) / nupdate);
	}
#endif
	dbl_EGlpNumFreeArray (f->work_coef);
	ILL_IFFREE(f->work_indx);

	ILL_IFFREE(f->uc_inf);
	if (f->dim + f->max_k > 0 && f->ur_inf)
	{
		unsigned int i = f->dim + f->max_k + 1;

		while (i--)
			dbl_EGlpNumClearVar (f->ur_inf[i].max);
	}
	ILL_IFFREE(f->ur_inf);
	ILL_IFFREE(f->lc_inf);
	ILL_IFFREE(f->lr_inf);
	ILL_IFFREE(f->er_inf);
	ILL_IFFREE(f->ucindx);
	ILL_IFFREE(f->ucrind);

	dbl_EGlpNumFreeArray (f->uccoef);
	ILL_IFFREE(f->urindx);
	ILL_IFFREE(f->urcind);

	dbl_EGlpNumFreeArray (f->urcoef);
	ILL_IFFREE(f->lcindx);

	dbl_EGlpNumFreeArray (f->lccoef);
	ILL_IFFREE(f->lrindx);

	dbl_EGlpNumFreeArray (f->lrcoef);
	ILL_IFFREE(f->erindx);

	dbl_EGlpNumFreeArray (f->ercoef);
	ILL_IFFREE(f->rperm);
	ILL_IFFREE(f->rrank);
	ILL_IFFREE(f->cperm);
	ILL_IFFREE(f->crank);

	dbl_EGlpNumFreeArray (f->dmat);
	dbl_ILLsvector_free (&f->xtmp);
}

int dbl_ILLfactor_set_factor_iparam (
	dbl_factor_work * f,
	int param,
	int val)
{
	switch (param)
	{
	case QS_FACTOR_MAX_K:
		f->max_k = val;
		break;
	case QS_FACTOR_P:
		f->p = val;
		break;
	case QS_FACTOR_ETAMAX:
		f->etamax = val;
		break;
	case QS_FACTOR_DENSE_MIN:
		f->dense_min = val;
		break;
	default:
		QSlog("Invalid param %d in dbl_ILLfactor_set_factor_iparam",
								param);
		return 1;
	}
	return 0;
}

int dbl_ILLfactor_set_factor_dparam (
	dbl_factor_work * f,
	int param,
	double val)
{
	switch (param)
	{
	case QS_FACTOR_FZERO_TOL:
		dbl_EGlpNumCopy (f->fzero_tol, val);
		break;
	case QS_FACTOR_SZERO_TOL:
		dbl_EGlpNumCopy (f->szero_tol, val);
		break;
	case QS_FACTOR_UR_SPACE_MUL:
		f->ur_space_mul = dbl_EGlpNumToLf (val);
		break;
	case QS_FACTOR_UC_SPACE_MUL:
		f->uc_space_mul = dbl_EGlpNumToLf (val);
		break;
	case QS_FACTOR_LC_SPACE_MUL:
		f->lc_space_mul = dbl_EGlpNumToLf (val);
		break;
	case QS_FACTOR_LR_SPACE_MUL:
		f->lr_space_mul = dbl_EGlpNumToLf (val);
		break;
	case QS_FACTOR_ER_SPACE_MUL:
		f->er_space_mul = dbl_EGlpNumToLf (val);
		break;
	case QS_FACTOR_GROW_MUL:
		f->grow_mul = dbl_EGlpNumToLf (val);
		break;
	case QS_FACTOR_MAXMULT:
		f->maxmult = dbl_EGlpNumToLf (val);
		break;
	case QS_FACTOR_UPDMAXMULT:
		f->updmaxmult = dbl_EGlpNumToLf (val);
		break;
	case QS_FACTOR_DENSE_FRACT:
		f->dense_fract = dbl_EGlpNumToLf (val);
		break;
	case QS_FACTOR_PARTIAL_TOL:
		dbl_EGlpNumCopy (f->partial_tol, val);
		dbl_EGlpNumCopy (f->partial_cur, val);
		break;
	default:
		QSlog("Invalid param %d in dbl_ILLfactor_set_factor_dparam",
								param);
		return 1;
	}
	return 0;
}

int dbl_ILLfactor_create_factor_work (
	dbl_factor_work * f,
	int dim)
{
	int i;
	int rval;

	f->dim = dim;
	f->etacnt = 0;
	f->work_coef = dbl_EGlpNumAllocArray (dim);
	ILL_SAFE_MALLOC (f->work_indx, dim, int);

	ILL_SAFE_MALLOC (f->uc_inf, dim + (f->max_k + 1), dbl_uc_info);
	ILL_SAFE_MALLOC (f->ur_inf, dim + (f->max_k + 1), dbl_ur_info);
	ILL_SAFE_MALLOC (f->lc_inf, dim, dbl_lc_info);
	ILL_SAFE_MALLOC (f->lr_inf, dim, dbl_lr_info);
	ILL_SAFE_MALLOC (f->rperm, dim, int);
	ILL_SAFE_MALLOC (f->rrank, dim, int);
	ILL_SAFE_MALLOC (f->cperm, dim, int);
	ILL_SAFE_MALLOC (f->crank, dim, int);

	for (i = dim + f->max_k + 1; i--;)
		dbl_EGlpNumInitVar (f->ur_inf[i].max);

	for (i = 0; i < dim; i++)
	{
		dbl_EGlpNumZero (f->work_coef[i]);
		f->work_indx[i] = 0;
		f->uc_inf[i].nzcnt = 0;
		f->ur_inf[i].nzcnt = 0;
		f->lc_inf[i].nzcnt = 0;
		f->lr_inf[i].nzcnt = 0;
		f->rperm[i] = i;
		f->rrank[i] = i;
		f->cperm[i] = i;
		f->crank[i] = i;
	}
	for (i = 0; i <= f->max_k; i++)
	{
		f->uc_inf[dim + i].nzcnt = i;
		f->uc_inf[dim + i].next = dim + i;
		f->uc_inf[dim + i].prev = dim + i;
		f->ur_inf[dim + i].nzcnt = i;
		f->ur_inf[dim + i].next = dim + i;
		f->ur_inf[dim + i].prev = dim + i;
	}

	rval = dbl_ILLsvector_alloc (&f->xtmp, dim);
	CHECKRVALG (rval, CLEANUP);

	rval = 0;

CLEANUP:
	if (rval)
	{
		dbl_ILLfactor_free_factor_work (f);
	}
	EG_RETURN (rval);
}
#ifdef FACTOR_DEBUG
static void dump_matrix (
	dbl_factor_work * f,
	int remaining)
{
	int dim = f->dim;
	dbl_ur_info *ur_inf = f->ur_inf;
	dbl_uc_info *uc_inf = f->uc_inf;
	dbl_lc_info *lc_inf = f->lc_inf;
	dbl_lr_info *lr_inf = f->lr_inf;
	dbl_er_info *er_inf = f->er_inf;
	int nzcnt;
	int beg;

	int i;
	int j;

	for (i = 0; i < dim; i++)
	{
		if (!remaining || ur_inf[i].next >= 0)
		{
			QSlog("Row %d %d (max %.3f):", i, f->rrank[i],
									dbl_EGlpNumToLf (ur_inf[i].max));
			nzcnt = ur_inf[i].nzcnt;
			beg = ur_inf[i].rbeg;
			for (j = 0; j < nzcnt; j++)
			{
				if (j == ur_inf[i].pivcnt)
				{
					QSlog(" |");
				}
				QSlog(" %.3f*%d", dbl_EGlpNumToLf (f->urcoef[beg + j]),
										f->urindx[beg + j]);
				if (f->urcind)
					QSlog("@%d", f->urcind[beg + j]);
			}
		}
	}
	if (f->dmat)
	{
		int start = 0;

		if (remaining)
			start = f->stage - f->dense_base;
		QSlog("Dcols at %d %d - %d    :", f->stage - f->dense_base,
								f->dense_base + start, f->nstages);
		for (j = start; j < f->dcols; j++)
		{
			QSlog(" %5d", f->cperm[j + f->dense_base]);
		}

		for (i = start; i < f->drows; i++)
		{
			QSlog("DRow %d %d (max %.3f):", i,
									f->rperm[i + f->dense_base],
									dbl_EGlpNumToLf (ur_inf[f->rperm[i + f->dense_base]].max));
			for (j = start; j < f->dcols; j++)
			{
				if (j == f->drows)
				{
					QSlog(" |");
				}
				QSlog(" %.3f", dbl_EGlpNumToLf (f->dmat[i * f->dcols + j]));
			}
		}
	}

	if (!remaining)
	{
		for (i = 0; i < f->stage; i++)
		{
			QSlog("L col %d:", lc_inf[i].c);
			nzcnt = lc_inf[i].nzcnt;
			beg = lc_inf[i].cbeg;
			for (j = 0; j < nzcnt; j++)
			{
				QSlog(" %.3f*%d", dbl_EGlpNumToLf (f->lccoef[beg + j]),
										f->lcindx[beg + j]);
			}
		}
		for (i = f->nstages; i < f->dim; i++)
		{
			QSlog("L col %d:", lc_inf[i].c);
			nzcnt = lc_inf[i].nzcnt;
			beg = lc_inf[i].cbeg;
			for (j = 0; j < nzcnt; j++)
			{
				QSlog(" %.3f*%d", dbl_EGlpNumToLf (f->lccoef[beg + j]),
										f->lcindx[beg + j]);
			}
		}
		for (i = 0; i < f->dim; i++)
		{
			if (!lr_inf[i].nzcnt)
				continue;
			QSlog("L row %d:", lr_inf[i].r);
			nzcnt = lr_inf[i].nzcnt;
			beg = lr_inf[i].rbeg;
			for (j = 0; j < nzcnt; j++)
			{
				QSlog(" %.3f*%d", dbl_EGlpNumToLf (f->lrcoef[beg + j]),
										f->lrindx[beg + j]);
			}
		}
	}

	if (!remaining)
	{
		for (i = 0; i < f->etacnt; i++)
		{
			QSlog("Eta row %d:", f->er_inf[i].r);
			nzcnt = er_inf[i].nzcnt;
			beg = er_inf[i].rbeg;
			for (j = 0; j < nzcnt; j++)
			{
				QSlog(" %.3f*%d", dbl_EGlpNumToLf (f->ercoef[beg + j]),
										f->erindx[beg + j]);
			}
		}
	}

	for (i = 0; i < dim; i++)
	{
		if (!remaining || uc_inf[i].next >= 0)
		{
			QSlog("Col %d %d:", i, f->crank[i]);
			nzcnt = uc_inf[i].nzcnt;
			beg = uc_inf[i].cbeg;
			for (j = 0; j < nzcnt; j++)
			{
				if (f->uccoef != 0)
				{
					QSlog(" %.3f*%d", dbl_EGlpNumToLf (f->uccoef[beg + j]),
											f->ucindx[beg + j]);
					if (f->ucrind)
						QSlog("@%d", f->ucrind[beg + j]);
				}
				else
				{
					QSlog(" %d", f->ucindx[beg + j]);
				}
			}
		}
	}

	if (!remaining)
	{
		QSlog("rperm:");
		for (i = 0; i < dim; i++)
		{
			if (i == f->nstages)
				QSlog("|");
			if (i == f->stage)
				QSlog("|");
			QSlog(" %d", f->rperm[i]);
		}

		QSlog("cperm:");
		for (i = 0; i < dim; i++)
		{
			if (i == f->nstages)
				QSlog("|");
			if (i == f->stage)
				QSlog("|");
			QSlog(" %d", f->cperm[i]);
		}
	}

	QSlog("Rows by nzcnt:");
	for (i = 0; i <= f->max_k; i++)
	{
		if (ur_inf[dim + i].next != dim + i)
		{
			QSlog("%d:", i);
			for (j = ur_inf[dim + i].next; j != dim + i; j = ur_inf[j].next)
			{
				QSlog(" %d", j);
			}
		}
	}

	QSlog("Cols by nzcnt:\n");
	for (i = 0; i <= f->max_k; i++)
	{
		if (uc_inf[dim + i].next != dim + i)
		{
			QSlog("%d:", i);
			for (j = uc_inf[dim + i].next; j != dim + i; j = uc_inf[j].next)
			{
				QSlog(" %d", j);
			}
		}
	}
}
#endif

#ifdef SORT_RESULTS
static void sort_vector2 (
	int nzcnt,
	int *indx,
	double * coef)
{
	int i;
	int j;
	int itmp;
	double ctmp;

	dbl_EGlpNumInitVar (ctmp);

	for (i = 1; i < nzcnt; i++)
	{
		itmp = indx[i];
		dbl_EGlpNumCopy (ctmp, coef[i]);
		for (j = i; j >= 1 && indx[j - 1] > itmp; j--)
		{
			indx[j] = indx[j - 1];
			dbl_EGlpNumCopy (coef[j], coef[j - 1]);
		}
		indx[j] = itmp;
		dbl_EGlpNumCopy (coef[j], ctmp);
	}
	dbl_EGlpNumClearVar (ctmp);
}

static void sort_vector (
	dbl_svector * x)
{
	sort_vector2 (x->nzcnt, x->indx, x->coef);
}
#endif

#ifdef DEBUG_FACTOR
static int check_matrix (
	dbl_factor_work * f)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	dbl_uc_info *uc_inf = f->uc_inf;
	int rbeg;
	int nzcnt;
	int cbeg;
	int c;
	int r;
	int j;
	int nerr = 0;

	for (r = 0; r < f->dim; r++)
	{
		nzcnt = ur_inf[r].nzcnt;
		rbeg = ur_inf[r].rbeg;
		for (j = 0; j < nzcnt; j++)
		{
			c = f->urindx[rbeg + j];
			cbeg = uc_inf[c].cbeg;
			if (f->ucindx[cbeg + f->urcind[rbeg + j]] != r)
			{
				MESSAGE(0,"index mismatch, row %d column %d", r, c);
				nerr++;
			}
			if (fabs(dbl_EGlpNumToLf(f->uccoef[cbeg + f->urcind[rbeg + j]]) - dbl_EGlpNumToLf(f->urcoef[rbeg + j]))>1000*dbl_EGlpNumToLf(dbl_epsLpNum))
			{
				MESSAGE(0,"coef mismatch, row %d column %d", r, c);
				nerr++;
			}
		}
	}
	if (f->urindx[f->ur_space] != 0)
	{
		MESSAGE(0,"last urindx entry %d != 0", f->urindx[f->ur_space]);
		nerr++;
	}

	for (c = 0; c < f->dim; c++)
	{
		nzcnt = uc_inf[c].nzcnt;
		cbeg = uc_inf[c].cbeg;
		for (j = 0; j < nzcnt; j++)
		{
			r = f->ucindx[cbeg + j];
			rbeg = ur_inf[r].rbeg;
			if (f->urindx[rbeg + f->ucrind[cbeg + j]] != c)
			{
				MESSAGE(0,"index mismatch, column %d row %d", c, r);
				nerr++;
			}
			if (f->urcoef[rbeg + f->ucrind[cbeg + j]] != f->uccoef[cbeg + j])
			{
				MESSAGE(0,"coef mismatch, column %d row %d", c, r);
				nerr++;
			}
		}
	}
	if (f->ucindx[f->uc_space] != 0)
	{
		MESSAGE(0,"last ucindx entry %d != 0", f->ucindx[f->uc_space]);
		nerr++;
	}
	if (nerr)
	{
		dump_matrix (f, 0);
		return E_CHECK_FAILED;
	}
	return 0;
}
#endif

#ifdef FACTOR_STATS
static void dump_factor_stats (
	dbl_factor_work * f)
{
	int dim = f->dim;
	int ecnt = f->etacnt;
	dbl_ur_info *ur_inf = f->ur_inf;
	dbl_lc_info *lc_inf = f->lc_inf;
	dbl_er_info *er_inf = f->er_inf;
	double *urcoef = f->urcoef;
	double *lccoef = f->lccoef;
	double *ercoef = f->ercoef;
	int lnzcnt = 0;
	int unzcnt = 0;
	int enzcnt = 0;
	int nzcnt;
	int beg;
	double umax;
	double lmax;
	double emax;
	int i;
	int j;

	dbl_EGlpNumInitVar (umax);
	dbl_EGlpNumInitVar (lmax);
	dbl_EGlpNumInitVar (emax);
	dbl_EGlpNumZero (umax);
	for (i = 0; i < dim; i++)
	{
		nzcnt = ur_inf[i].nzcnt;
		beg = ur_inf[i].rbeg;
		unzcnt += nzcnt;
		for (j = 0; j < nzcnt; j++)
		{
			dbl_EGlpNumSetToMaxAbs (umax, urcoef[beg + j]);
		}
	}
	dbl_EGlpNumZero (lmax);
	for (i = 0; i < dim; i++)
	{
		nzcnt = lc_inf[i].nzcnt;
		beg = lc_inf[i].cbeg;
		lnzcnt += nzcnt;
		for (j = 0; j < nzcnt; j++)
		{
			dbl_EGlpNumSetToMaxAbs (lmax, lccoef[beg + j]);
		}
	}
	dbl_EGlpNumZero (emax);
	for (i = 0; i < ecnt; i++)
	{
		nzcnt = er_inf[i].nzcnt;
		beg = er_inf[i].rbeg;
		enzcnt += nzcnt;
		for (j = 0; j < nzcnt; j++)
		{
			dbl_EGlpNumSetToMaxAbs (emax, ercoef[beg + j]);
		}
	}
	MESSAGE(0, "factor U %d nzs %.3e max L %d nzs %.3e max E %d nzs %.3e max",
					unzcnt, dbl_EGlpNumToLf (umax), lnzcnt, dbl_EGlpNumToLf (lmax), enzcnt,
					dbl_EGlpNumToLf (emax));
	dbl_EGlpNumClearVar (umax);
	dbl_EGlpNumClearVar (lmax);
	dbl_EGlpNumClearVar (emax);
}
#endif

static void clear_work (
	dbl_factor_work * f)
{
	int i;
	int dim = f->dim;
	double *work_coef = f->work_coef;

	for (i = 0; i < dim; i++)
	{
		dbl_EGlpNumZero (work_coef[i]);
	}
}

static void load_row (
	dbl_factor_work * f,
	int r)
{
	double *prow_urcoef = f->urcoef + f->ur_inf[r].rbeg;
	int *prow_urindx = f->urindx + f->ur_inf[r].rbeg;
	int prow_nzcnt = f->ur_inf[r].nzcnt;
	double *work_coef = f->work_coef;
	int *work_indx = f->work_indx;
	int i;
	int j;

	for (i = 0; i < prow_nzcnt; i++)
	{
		j = prow_urindx[i];
		dbl_EGlpNumCopy (work_coef[j], prow_urcoef[i]);
		work_indx[j] = 1;
	}
}

static void clear_row (
	dbl_factor_work * f,
	int r)
{
	int *prow_urindx = f->urindx + f->ur_inf[r].rbeg;
	int prow_nzcnt = f->ur_inf[r].nzcnt;
	double *work_coef = f->work_coef;
	int *work_indx = f->work_indx;
	int i;
	int j;

	for (i = 0; i < prow_nzcnt; i++)
	{
		j = prow_urindx[i];
		dbl_EGlpNumZero (work_coef[j]);
		work_indx[j] = 0;
	}
}

static int make_ur_space (
	dbl_factor_work * f,
	int space)
{
	double *new_urcoef = 0;
	int *new_urindx = 0;
	int *new_urcind = 0;
	double *urcoef = f->urcoef;
	int *urindx = f->urindx;
	int *urcind = f->urcind;
	int minspace;
	dbl_ur_info *ur_inf = f->ur_inf;
	int dim = f->dim;
	int new_nzcnt = 0, old_nzcnt;
	int rbeg;
	int nzcnt;
	int i;
	int j;
	int rval;

	minspace = f->ur_space;
	nzcnt = space;
	for (i = 0; i < dim; i++)
		nzcnt += ur_inf[i].nzcnt;
	old_nzcnt = nzcnt;
	while (nzcnt * 2 >= minspace)
	{
		minspace = 1 + minspace * f->grow_mul;
	}

#ifdef GROWTH_STATS
	QSlog("make_ur_space growing from %d to %d...", f->ur_space, minspace);
#endif
	new_urcoef = dbl_EGlpNumAllocArray (minspace);
	ILL_SAFE_MALLOC (new_urindx, minspace + 1, int);

	if (urcind)
	{
		ILL_SAFE_MALLOC (new_urcind, minspace, int);
	}

	if (urcind)
	{
		for (j = 0; j < dim; j++)
		{
			rbeg = ur_inf[j].rbeg;
			nzcnt = ur_inf[j].nzcnt;
			ur_inf[j].rbeg = new_nzcnt;
			for (i = 0; i < nzcnt; i++)
			{
				new_urindx[new_nzcnt] = urindx[rbeg + i];
				dbl_EGlpNumCopy (new_urcoef[new_nzcnt], urcoef[rbeg + i]);
				new_urcind[new_nzcnt] = urcind[rbeg + i];
				new_nzcnt++;
			}
		}
	}
	else
	{
		for (j = 0; j < dim; j++)
		{
			rbeg = ur_inf[j].rbeg;
			nzcnt = ur_inf[j].nzcnt;
			ur_inf[j].rbeg = new_nzcnt;
			for (i = 0; i < nzcnt; i++)
			{
				new_urindx[new_nzcnt] = urindx[rbeg + i];
				dbl_EGlpNumCopy (new_urcoef[new_nzcnt], urcoef[rbeg + i]);
				new_nzcnt++;
			}
		}
	}

	for (i = new_nzcnt; i < minspace; i++)
	{
		new_urindx[i] = -1;
	}
	new_urindx[minspace] = 0;
	dbl_EGlpNumFreeArray (f->urcoef);
	f->urcoef = new_urcoef;
	new_urcoef = 0;

	ILL_IFFREE(f->urindx);

	f->urindx = new_urindx;
	new_urindx = 0;

	ILL_IFFREE(f->urcind);

	f->urcind = new_urcind;
	new_urcind = 0;

	f->ur_freebeg = new_nzcnt;
	f->ur_space = minspace;

#ifdef GROWTH_STATS
	MESSAGE (0,"%d/%d nonzeros", new_nzcnt, old_nzcnt);
	dump_factor_stats (f);
#endif

	rval = 0;

CLEANUP:
	ILL_IFFREE(new_urcoef);
	ILL_IFFREE(new_urindx);
	ILL_IFFREE(new_urcind);

	EG_RETURN (rval);
}

static int make_uc_space (
	dbl_factor_work * f,
	int space)
{
	double *new_uccoef = 0;
	int *new_ucindx = 0;
	int *new_ucrind = 0;
	int uc_freebeg = f->uc_freebeg;
	double *uccoef = f->uccoef;
	int *ucindx = f->ucindx;
	int *ucrind = f->ucrind;
	int minspace = uc_freebeg + space;
	dbl_uc_info *uc_inf = f->uc_inf;
	int dim = f->dim;
	int new_nzcnt = 0;
	int cbeg;
	int nzcnt;
	int i;
	int j;
	int rval;

	minspace = f->uc_space;
	nzcnt = space;
	for( i = 0 ; i < dim ; i++) nzcnt += uc_inf[i].nzcnt;
	while(nzcnt*2 >= minspace)
	{
		minspace = 10 + (f->grow_mul * minspace);
	}

#ifdef GROWTH_STATS
	MESSAGE (0,"make_uc_space growing from %d to %d...", f->uc_space, minspace);
#endif

	ILL_SAFE_MALLOC (new_ucindx, minspace + 1, int);

	if (ucrind)
	{
		new_uccoef = dbl_EGlpNumAllocArray (minspace);
		ILL_SAFE_MALLOC (new_ucrind, minspace, int);
	}

	if (ucrind)
	{
		for (j = 0; j < dim; j++)
		{
			cbeg = uc_inf[j].cbeg;
			nzcnt = uc_inf[j].nzcnt;
			uc_inf[j].cbeg = new_nzcnt;
			for (i = 0; i < nzcnt; i++)
			{
				new_ucindx[new_nzcnt] = ucindx[cbeg + i];
				dbl_EGlpNumCopy (new_uccoef[new_nzcnt], uccoef[cbeg + i]);
				new_ucrind[new_nzcnt] = ucrind[cbeg + i];
				new_nzcnt++;
			}
		}
	}
	else
	{
		for (j = 0; j < dim; j++)
		{
			cbeg = uc_inf[j].cbeg;
			nzcnt = uc_inf[j].nzcnt;
			uc_inf[j].cbeg = new_nzcnt;
			for (i = 0; i < nzcnt; i++)
			{
				new_ucindx[new_nzcnt] = ucindx[cbeg + i];
				new_nzcnt++;
			}
		}
	}

	for (i = new_nzcnt; i < minspace; i++)
	{
		new_ucindx[i] = -1;
	}
	new_ucindx[minspace] = 0;

	dbl_EGlpNumFreeArray (f->uccoef);
	f->uccoef = new_uccoef;
	new_uccoef = 0;

	ILL_IFFREE(f->ucindx);

	f->ucindx = new_ucindx;
	new_ucindx = 0;

	ILL_IFFREE(f->ucrind);

	f->ucrind = new_ucrind;
	new_ucrind = 0;

	f->uc_freebeg = new_nzcnt;
	f->uc_space = minspace;

#ifdef GROWTH_STATS
	MESSAGE (0,"%d nonzeros", new_nzcnt);
	dump_factor_stats (f);
#endif

	rval = 0;

CLEANUP:
	ILL_IFFREE(new_uccoef);
	ILL_IFFREE(new_ucindx);
	ILL_IFFREE(new_ucrind);

	EG_RETURN (rval);
}

static int make_lc_space (
	dbl_factor_work * f,
	int space)
{
	double *new_lccoef = 0;
	int *new_lcindx = 0;
	int lc_freebeg = f->lc_freebeg;
	double *lccoef = f->lccoef;
	int *lcindx = f->lcindx;
	int minspace = lc_freebeg + space;
	int i;
	int rval;

	if (f->lc_space * f->grow_mul > minspace)
	{
		minspace = f->lc_space * f->grow_mul;
	}

#ifdef GROWTH_STATS
	MESSAGE (0,"make_lc_space growing from %d to %d...", f->lc_space, minspace);
#endif

	new_lccoef = dbl_EGlpNumAllocArray (minspace);
	ILL_SAFE_MALLOC (new_lcindx, minspace, int);

	for (i = 0; i < lc_freebeg; i++)
	{
		dbl_EGlpNumCopy (new_lccoef[i], lccoef[i]);
		new_lcindx[i] = lcindx[i];
	}

	dbl_EGlpNumFreeArray (lccoef);
	f->lccoef = new_lccoef;
	new_lccoef = 0;

	ILL_IFFREE(lcindx);

	f->lcindx = new_lcindx;
	new_lcindx = 0;

	f->lc_space = minspace;

#ifdef GROWTH_STATS
	dump_factor_stats (f);
#endif

	rval = 0;

CLEANUP:
	ILL_IFFREE(new_lccoef);
	ILL_IFFREE(new_lcindx);

	EG_RETURN (rval);
}

static void set_col_nz (
	dbl_factor_work * f,
	int c)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	int nzcnt = uc_inf[c].nzcnt;
	int max_k = f->max_k;
	int dim = f->dim;

	if (uc_inf[c].next >= 0)
	{
		uc_inf[uc_inf[c].next].prev = uc_inf[c].prev;
		uc_inf[uc_inf[c].prev].next = uc_inf[c].next;

		if (nzcnt >= max_k)
			nzcnt = max_k;
		uc_inf[c].next = uc_inf[dim + nzcnt].next;
		uc_inf[c].prev = dim + nzcnt;
		uc_inf[dim + nzcnt].next = c;
		uc_inf[uc_inf[c].next].prev = c;
	}
}

static void set_row_nz (
	dbl_factor_work * f,
	int r)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	int nzcnt = ur_inf[r].pivcnt;
	int max_k = f->max_k;
	int dim = f->dim;

	if (ur_inf[r].next >= 0)
	{
		ur_inf[ur_inf[r].next].prev = ur_inf[r].prev;
		ur_inf[ur_inf[r].prev].next = ur_inf[r].next;

		if (nzcnt >= max_k)
			nzcnt = max_k;
		ur_inf[r].next = ur_inf[dim + nzcnt].next;
		ur_inf[r].prev = dim + nzcnt;
		ur_inf[dim + nzcnt].next = r;
		ur_inf[ur_inf[r].next].prev = r;
	}
}

static void remove_col_nz (
	dbl_factor_work * f,
	int r,
	int c)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	int *ucindx = f->ucindx + uc_inf[c].cbeg;
	int nzcnt = uc_inf[c].nzcnt;
	int i;

	for (i = 0; i < nzcnt; i++)
	{
		if (ucindx[i] == r)
		{
			--nzcnt;
			ucindx[i] = ucindx[nzcnt];
			ucindx[nzcnt] = -1;
			break;
		}
	}
	uc_inf[c].nzcnt = nzcnt;

	set_col_nz (f, c);
}

static void remove_row_nz (
	dbl_factor_work * f,
	int r,
	int c)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	int *urindx = f->urindx + ur_inf[r].rbeg;
	double *urcoef = f->urcoef + ur_inf[r].rbeg;
	int pivcnt = ur_inf[r].pivcnt;
	double max;
	int tind;
	double tcoef;
	int i;

	dbl_EGlpNumInitVar (tcoef);
	dbl_EGlpNumInitVar (max);
	dbl_EGlpNumZero (max);

	for (i = 0; i < pivcnt; i++)
	{
		if (urindx[i] == c)
		{
			--pivcnt;
			ILL_SWAP (urindx[i], urindx[pivcnt], tind);
			dbl_EGLPNUM_SWAP (urcoef[i], urcoef[pivcnt], tcoef);
			--i;
		}
		else
		{
			dbl_EGlpNumSetToMaxAbs (max, urcoef[i]);
		}
	}
	ur_inf[r].pivcnt = pivcnt;
	dbl_EGlpNumCopy (ur_inf[r].max, max);
	set_row_nz (f, r);
	dbl_EGlpNumClearVar (max);
	dbl_EGlpNumClearVar (tcoef);
}

static int add_col_nz (
	dbl_factor_work * f,
	int r,
	int c)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	int cbeg = uc_inf[c].cbeg;
	int nzcnt = uc_inf[c].nzcnt;
	int uc_freebeg = f->uc_freebeg;
	int *ucindx = f->ucindx;
	int i;
	int rval = 0;

	if (uc_inf[c].next == -1)
	{
		return 0;
	}

	if (ucindx[cbeg + nzcnt] == -1)
	{
		ucindx[cbeg + nzcnt] = r;
		uc_inf[c].nzcnt++;
		if (nzcnt + cbeg == uc_freebeg)
		{
			f->uc_freebeg = uc_freebeg + 1;
		}
	}
	else
	{
		if (uc_freebeg + nzcnt + 1 >= f->uc_space)
		{
			rval = make_uc_space (f, nzcnt + 1);
			CHECKRVALG (rval, CLEANUP);
			uc_freebeg = f->uc_freebeg;
			cbeg = uc_inf[c].cbeg;
			ucindx = f->ucindx;
		}
		for (i = 0; i < nzcnt; i++)
		{
			ucindx[uc_freebeg + i] = ucindx[cbeg + i];
			ucindx[cbeg + i] = -1;
		}
		ucindx[uc_freebeg + nzcnt] = r;
		uc_inf[c].cbeg = uc_freebeg;
		uc_inf[c].nzcnt++;
		f->uc_freebeg = uc_freebeg + nzcnt + 1;
	}

	set_col_nz (f, c);
CLEANUP:
	EG_RETURN (rval);
}

static void disable_col (
	dbl_factor_work * f,
	int c)
{
	dbl_uc_info *uc_inf = f->uc_inf;

	if (uc_inf[c].next >= 0)
	{
		uc_inf[uc_inf[c].next].prev = uc_inf[c].prev;
		uc_inf[uc_inf[c].prev].next = uc_inf[c].next;

		uc_inf[c].next = -2;
		uc_inf[c].prev = -2;
	}
}

static void remove_col (
	dbl_factor_work * f,
	int c)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	int cbeg = uc_inf[c].cbeg;
	int nzcnt = uc_inf[c].nzcnt;
	int *ucindx = f->ucindx;
	int i;

	for (i = 0; i < nzcnt; i++)
	{
		ucindx[cbeg + i] = -1;
	}
	uc_inf[c].cbeg = 0;
	uc_inf[c].nzcnt = 0;

	if (uc_inf[c].next >= 0)
	{
		uc_inf[uc_inf[c].next].prev = uc_inf[c].prev;
		uc_inf[uc_inf[c].prev].next = uc_inf[c].next;

		uc_inf[c].next = -1;
		uc_inf[c].prev = -1;
	}
}

static void remove_row (
	dbl_factor_work * f,
	int r)
{
	dbl_ur_info *ur_inf = f->ur_inf;

	if (ur_inf[r].next >= 0)
	{
		ur_inf[ur_inf[r].next].prev = ur_inf[r].prev;
		ur_inf[ur_inf[r].prev].next = ur_inf[r].next;

		ur_inf[r].next = -1;
		ur_inf[r].prev = -1;
	}
}

static void find_coef (
	dbl_factor_work * f,
	int r,
	int c,
	double * coef)
{
	double *prow_urcoef = f->urcoef + f->ur_inf[r].rbeg;
	int *prow_urindx = f->urindx + f->ur_inf[r].rbeg;
	int i;
	int prow_nzcnt = f->ur_inf[r].nzcnt;

	dbl_EGlpNumZero (*coef);
	for (i = 0; i < prow_nzcnt; i++)
	{
		if (prow_urindx[i] == c)
		{
			dbl_EGlpNumCopy (*coef, prow_urcoef[i]);
			return;
		}
	}
	QSlog("Coefficient not found");
	return;
}

static int elim_row (
	dbl_factor_work * f,
	int elim_r,
	int r,
	int c,
	double * p_pivot_coef)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	double *work_coef = f->work_coef;
	int *work_indx = f->work_indx;
	double *urcoef = f->urcoef;
	int *urindx = f->urindx;
	int prow_beg = ur_inf[r].rbeg;
	int prow_nzcnt = ur_inf[r].nzcnt;
	int prow_pivcnt = ur_inf[r].pivcnt;
	int fill = ur_inf[elim_r].nzcnt;
	int cancel = 0;
	double max;
	int erow_beg;
	int erow_nzcnt;
	int erow_pivcnt;
	double x;
	int i;
	int j;
	int rval = 0;
	double elim_coef;

	dbl_EGlpNumInitVar (max);
	dbl_EGlpNumInitVar (x);
	dbl_EGlpNumInitVar (elim_coef);
	dbl_EGlpNumZero (max);
	find_coef (f, r, c, &elim_coef);
	dbl_EGlpNumDivTo (elim_coef, work_coef[c]);
	dbl_EGlpNumCopy (*p_pivot_coef, elim_coef);

	for (i = 0; i < prow_nzcnt; i++)
	{
		j = urindx[prow_beg + i];
		if (work_indx[j] == 1)
		{
			dbl_EGlpNumCopy (x, urcoef[prow_beg + i]);
			dbl_EGlpNumSubInnProdTo (x, elim_coef, work_coef[j]);
			if ((!(dbl_EGlpNumIsNeqZero (x, f->fzero_tol))) || j == c)
			{
				cancel++;
				if (j != c)
				{
					remove_col_nz (f, r, j);
				}
				if (i < prow_pivcnt)
				{
					prow_pivcnt--;
					prow_nzcnt--;
					urindx[prow_beg + i] = urindx[prow_beg + prow_pivcnt];
					dbl_EGlpNumCopy (urcoef[prow_beg + i], urcoef[prow_beg + prow_pivcnt]);
					if (prow_pivcnt != prow_nzcnt)
					{
						urindx[prow_beg + prow_pivcnt] = urindx[prow_beg + prow_nzcnt];
						dbl_EGlpNumCopy (urcoef[prow_beg + prow_pivcnt],
												 urcoef[prow_beg + prow_nzcnt]);
					}
				}
				else
				{
					prow_nzcnt--;
					urindx[prow_beg + i] = urindx[prow_beg + prow_nzcnt];
					dbl_EGlpNumCopy (urcoef[prow_beg + i], urcoef[prow_beg + prow_nzcnt]);
				}
				urindx[prow_beg + prow_nzcnt] = -1;
				i--;
			}
			else
			{
				dbl_EGlpNumCopy (urcoef[prow_beg + i], x);
				if (i < prow_pivcnt)
				{
					dbl_EGlpNumSetToMaxAbs (max, x);
				}
			}
			work_indx[j] = 0;
			fill--;
		}
		else
		{
			if (i < prow_pivcnt)
			{
				dbl_EGlpNumSetToMaxAbs (max, urcoef[prow_beg + i]);
			}
		}
	}

	if (fill > 0)
	{
		ur_inf[r].nzcnt = prow_nzcnt;
		ur_inf[r].pivcnt = prow_pivcnt;
		if (fill > cancel)
		{
			int ur_freebeg = f->ur_freebeg;

			if (ur_freebeg + prow_nzcnt + fill >= f->ur_space)
			{
				rval = make_ur_space (f, prow_nzcnt + fill);
				CHECKRVALG (rval, CLEANUP);
				urcoef = f->urcoef;
				urindx = f->urindx;
				ur_freebeg = f->ur_freebeg;
				prow_beg = f->ur_inf[r].rbeg;
			}
			for (i = 0; i < prow_nzcnt; i++)
			{
				urindx[ur_freebeg + i] = urindx[prow_beg + i];
				dbl_EGlpNumCopy (urcoef[ur_freebeg + i], urcoef[prow_beg + i]);
				urindx[prow_beg + i] = -1;
			}
			ur_inf[r].rbeg = ur_freebeg;
			f->ur_freebeg = ur_freebeg + prow_nzcnt + fill;
			prow_beg = ur_freebeg;
		}

		erow_beg = ur_inf[elim_r].rbeg;
		erow_nzcnt = ur_inf[elim_r].nzcnt;
		erow_pivcnt = ur_inf[elim_r].pivcnt;

		for (i = 0; i < erow_pivcnt; i++)
		{
			j = urindx[erow_beg + i];
			if (work_indx[j] == 1)
			{
				dbl_EGlpNumCopyNeg (x, elim_coef);
				dbl_EGlpNumMultTo (x, urcoef[erow_beg + i]);
				if (dbl_EGlpNumIsNeqZero (x, f->fzero_tol))
				{
					rval = add_col_nz (f, r, j);
					CHECKRVALG (rval, CLEANUP);
					if (prow_pivcnt != prow_nzcnt)
					{
						urindx[prow_beg + prow_nzcnt] = urindx[prow_beg + prow_pivcnt];
						dbl_EGlpNumCopy (urcoef[prow_beg + prow_nzcnt],
												 urcoef[prow_beg + prow_pivcnt]);
					}
					urindx[prow_beg + prow_pivcnt] = j;
					dbl_EGlpNumCopy (urcoef[prow_beg + prow_pivcnt], x);
					dbl_EGlpNumSetToMaxAbs (max, x);
					prow_pivcnt++;
					prow_nzcnt++;
				}
			}
			else
			{
				work_indx[j] = 1;
			}
		}
		for (i = erow_pivcnt; i < erow_nzcnt; i++)
		{
			j = urindx[erow_beg + i];
			if (work_indx[j] == 1)
			{
				dbl_EGlpNumCopyNeg (x, elim_coef);
				dbl_EGlpNumMultTo (x, urcoef[erow_beg + i]);
				if (dbl_EGlpNumIsNeqZero (x, f->fzero_tol))
				{
					rval = add_col_nz (f, r, j);
					CHECKRVALG (rval, CLEANUP);
					urindx[prow_beg + prow_nzcnt] = j;
					dbl_EGlpNumCopy (urcoef[prow_beg + prow_nzcnt], x);
					prow_nzcnt++;
				}
			}
			else
			{
				work_indx[j] = 1;
			}
		}
	}
	else
	{
		erow_nzcnt = ur_inf[elim_r].nzcnt;
		erow_beg = ur_inf[elim_r].rbeg;
		for (i = 0; i < erow_nzcnt; i++)
		{
			j = urindx[erow_beg + i];
			work_indx[j] = 1;
		}
	}

	ur_inf[r].nzcnt = prow_nzcnt;
	ur_inf[r].pivcnt = prow_pivcnt;
	dbl_EGlpNumCopy (ur_inf[r].max, max);

	set_row_nz (f, r);
CLEANUP:
	dbl_EGlpNumClearVar (elim_coef);
	dbl_EGlpNumClearVar (x);
	dbl_EGlpNumClearVar (max);
	EG_RETURN (rval);
}

#define SETPERM(f,s,r,c) {                    \
        f->rperm[f->rrank[r]] = f->rperm[s];  \
        f->rrank[f->rperm[s]] = f->rrank[r];  \
        f->rperm[s] = r;                      \
        f->rrank[r] = s;                      \
                                              \
        f->cperm[f->crank[c]] = f->cperm[s];  \
        f->crank[f->cperm[s]] = f->crank[c];  \
        f->cperm[s] = c;                      \
        f->crank[c] = s;                      \
}

static int elim (
	dbl_factor_work * f,
	int r,
	int c)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	dbl_ur_info *ur_inf = f->ur_inf;
	dbl_lc_info *lc_inf = f->lc_inf;
	int *urindx;
	int *ucindx;
	int *lcindx;
	double *urcoef;
	double *lccoef;
	double pivot_coef;
	int nzcnt;
	int lc_freebeg;
	int s = f->stage;
	int i;
	int j;
	int rval = 0;

	dbl_EGlpNumInitVar (pivot_coef);

	if (uc_inf[c].nzcnt == 1)
	{
		/* col singleton */
		SETPERM (f, s, r, c);

		lc_inf[s].cbeg = -1;
		lc_inf[s].c = r;
		lc_inf[s].nzcnt = 0;
		f->stage++;

		urindx = f->urindx + ur_inf[r].rbeg;
		urcoef = f->urcoef + ur_inf[r].rbeg;
		nzcnt = ur_inf[r].nzcnt;
		for (i = 0; i < nzcnt; i++)
		{
			j = urindx[i];
			remove_col_nz (f, r, j);
			if (j == c)
			{
				urindx[i] = urindx[0];
				urindx[0] = c;
				dbl_EGLPNUM_SWAP (urcoef[0], urcoef[i], pivot_coef);
			}
		}
		remove_row (f, r);
		remove_col (f, c);
	}
	else if (ur_inf[r].nzcnt == 1)
	{
		/* row singleton */
		--(f->nstages);
		SETPERM (f, f->nstages, r, c);

		lc_inf[f->nstages].cbeg = -1;
		lc_inf[f->nstages].c = r;
		lc_inf[f->nstages].nzcnt = 0;

		ucindx = f->ucindx + uc_inf[c].cbeg;
		nzcnt = uc_inf[c].nzcnt;
		for (i = 0; i < nzcnt; i++)
		{
			j = ucindx[i];
			remove_row_nz (f, j, c);
		}
		remove_row (f, r);
		remove_col (f, c);
	}
	else
	{
		SETPERM (f, s, r, c);
		f->stage++;

		nzcnt = uc_inf[c].nzcnt;
		if (f->lc_freebeg + nzcnt >= f->lc_space)
		{
			rval = make_lc_space (f, nzcnt);
			CHECKRVALG (rval, CLEANUP);
		}
		lc_freebeg = f->lc_freebeg;
		lc_inf[s].cbeg = lc_freebeg;
		lc_inf[s].c = r;
		lcindx = f->lcindx;
		lccoef = f->lccoef;
		load_row (f, r);
		ucindx = f->ucindx + uc_inf[c].cbeg;
		for (i = 0; i < nzcnt; i++)
		{
			j = f->ucindx[uc_inf[c].cbeg + i];
			if (j != r)
			{
				rval = elim_row (f, r, j, c, &pivot_coef);
				CHECKRVALG (rval, CLEANUP);
				lcindx[lc_freebeg] = j;
				dbl_EGlpNumCopy (lccoef[lc_freebeg], pivot_coef);
				lc_freebeg++;
#ifdef TRACK_FACTOR
				dbl_EGlpNumSetToMaxAbs (f->maxelem_factor, pivot_coef);
				if (dbl_EGlpNumIsLess (f->maxelem_factor, ur_inf[r].max))
					dbl_EGlpNumCopy (f->maxelem_factor, ur_inf[r].max);
#endif /* TRACK_FACTOR */
			}
		}
		lc_inf[s].nzcnt = lc_freebeg - lc_inf[s].cbeg;
		f->lc_freebeg = lc_freebeg;

		clear_row (f, r);

		urindx = f->urindx + ur_inf[r].rbeg;
		urcoef = f->urcoef + ur_inf[r].rbeg;
		nzcnt = ur_inf[r].nzcnt;
		for (i = 0; i < nzcnt; i++)
		{
			j = urindx[i];
			remove_col_nz (f, r, j);
			if (j == c)
			{
				urindx[i] = urindx[0];
				urindx[0] = c;
				dbl_EGLPNUM_SWAP (urcoef[0], urcoef[i], pivot_coef);
			}
		}
		remove_row (f, r);
		remove_col (f, c);
	}
CLEANUP:
	dbl_EGlpNumClearVar (pivot_coef);
	EG_RETURN (rval);
}

static void find_pivot_column (
	dbl_factor_work * f,
	int c,
	int *p_r)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	dbl_ur_info *ur_inf = f->ur_inf;
	int *ucindx = f->ucindx;
	int nzcnt = uc_inf[c].nzcnt;
	int cbeg = uc_inf[c].cbeg;
	double num_tmp[2];
	int bestnz = -1;
	int i;
	int r;

	dbl_EGlpNumInitVar (num_tmp[0]);
	dbl_EGlpNumInitVar (num_tmp[1]);

	*p_r = -1;
	for (i = 0; i < nzcnt; i++)
	{
		r = ucindx[cbeg + i];
		if((bestnz == -1 || ur_inf[r].pivcnt < bestnz))
		{
			find_coef (f, r, c, num_tmp);
			if(dbl_EGlpNumIsLessZero(num_tmp[0]))
				dbl_EGlpNumSign (num_tmp[0]);
			dbl_EGlpNumCopy (num_tmp[1], f->partial_cur);
			dbl_EGlpNumMultTo (num_tmp[1], ur_inf[r].max);
			if(dbl_EGlpNumIsLeq (num_tmp[1], num_tmp[0]))
			{
				bestnz = ur_inf[r].pivcnt;
				*p_r = r;
			}
		}
	}
	dbl_EGlpNumClearVar (num_tmp[0]);
	dbl_EGlpNumClearVar (num_tmp[1]);
}

static void find_pivot_row (
	dbl_factor_work * f,
	int r,
	int *p_c)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	dbl_ur_info *ur_inf = f->ur_inf;
	int *urindx = f->urindx;
	double *urcoef = f->urcoef;
	int pivcnt = ur_inf[r].pivcnt;
	int rbeg = ur_inf[r].rbeg;
	double thresh[2];
	int bestnz = -1;
	int i;
	int c;

	dbl_EGlpNumInitVar (thresh[0]);
	dbl_EGlpNumInitVar (thresh[1]);
	dbl_EGlpNumCopy (thresh[0], f->partial_cur);
	dbl_EGlpNumMultTo (thresh[0], ur_inf[r].max);
	*p_c = -1;
	for (i = 0; i < pivcnt; i++)
	{
		c = urindx[rbeg + i];
		if ((bestnz == -1 || uc_inf[c].nzcnt < bestnz))
		{
			dbl_EGlpNumCopyAbs (thresh[1], urcoef[rbeg + i]);
			if(dbl_EGlpNumIsLeq (thresh[0], thresh[1]))
			{
				bestnz = uc_inf[c].nzcnt;
				*p_c = c;
			}
		}
	}
	dbl_EGlpNumClearVar (thresh[0]);
	dbl_EGlpNumClearVar (thresh[1]);
}

static int find_pivot (
	dbl_factor_work * f,
	int *p_r,
	int *p_c)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	dbl_ur_info *ur_inf = f->ur_inf;
	int dim = f->dim;
	int max_k = f->max_k;
	int p = f->p;
	int c;
	int r;
	int mm = 0;
	int n = 0;
	int m;
	int k = 2;

	if (uc_inf[dim + 1].next != dim + 1)
	{
		c = uc_inf[dim + 1].next;
		r = f->ucindx[uc_inf[c].cbeg];
		*p_c = c;
		*p_r = r;
		return 0;
	}
	else if (ur_inf[dim + 1].next != dim + 1)
	{
		r = ur_inf[dim + 1].next;
		c = f->urindx[ur_inf[r].rbeg];
		*p_c = c;
		*p_r = r;
		return 0;
	}
	*p_r = -1;
	*p_c = -1;
	for (; k <= max_k && (mm == 0 || mm > (k - 1) * (k - 1)); k++)
	{
		if (uc_inf[dim + k].next != dim + k)
		{
			for (c = uc_inf[dim + k].next; c != dim + k; c = uc_inf[c].next)
			{
				find_pivot_column (f, c, &r);
				if (r >= 0)
				{
					m = (uc_inf[c].nzcnt - 1) * (ur_inf[r].pivcnt - 1);
					if (mm == 0 || m < mm)
					{
						mm = m;
						*p_c = c;
						*p_r = r;
						if (mm <= (k - 1) * (k - 1))
						{
							return 0;
						}
					}
				}
				else
				{
					c = uc_inf[c].prev;
					disable_col (f, uc_inf[c].next);
				}
				n++;
				if (n >= p && mm != 0)
				{
					return 0;
				}
			}
		}

		if (ur_inf[dim + k].next != dim + k)
		{
			for (r = ur_inf[dim + k].next; r != dim + k; r = ur_inf[r].next)
			{
				find_pivot_row (f, r, &c);
				if (c >= 0)
				{
					m = (uc_inf[c].nzcnt - 1) * (ur_inf[r].pivcnt - 1);
					if (mm == 0 || m < mm)
					{
						mm = m;
						*p_c = c;
						*p_r = r;
						if (mm <= k * (k - 1))
						{
							return 0;
						}
					}
				}
				n++;
				if (n >= p && mm != 0)
				{
					return 0;
				}
			}
		}
	}
	if (mm != 0)
	{
		return 0;
	}
	else
	{
		//QSlog("No acceptable pivot found");
		return E_NO_PIVOT;
	}
}

static int create_factor_space (
	dbl_factor_work * f)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	dbl_ur_info *ur_inf = f->ur_inf;
	int dim = f->dim;
	int nzcnt;
	int i;
	int rval;

	nzcnt = 0;
	for (i = 0; i < dim; i++)
	{
		nzcnt += ur_inf[i].nzcnt;
	}

	if (f->ucindx == 0)
	{
		f->uc_space = nzcnt * f->uc_space_mul;
		ILL_SAFE_MALLOC (f->ucindx, f->uc_space + 1, int);
	}

	if (f->urindx == 0 || f->urcoef == 0)
	{
		ILL_IFFREE(f->urindx);

		dbl_EGlpNumFreeArray (f->urcoef);
		f->ur_space = nzcnt * f->ur_space_mul;
		ILL_SAFE_MALLOC (f->urindx, f->ur_space + 1, int);

		f->urcoef = dbl_EGlpNumAllocArray (f->ur_space);
	}

	if (f->lcindx == 0 || f->lccoef == 0)
	{
		ILL_IFFREE(f->lcindx);

		dbl_EGlpNumFreeArray (f->lccoef);
		f->lc_space = nzcnt * f->lc_space_mul;
		ILL_SAFE_MALLOC (f->lcindx, f->lc_space, int);

		f->lccoef = dbl_EGlpNumAllocArray (f->lc_space);
	}

	nzcnt = 0;
	for (i = 0; i < dim; i++)
	{
		ur_inf[i].rbeg = nzcnt;
		nzcnt += ur_inf[i].nzcnt;
		ur_inf[i].nzcnt = ur_inf[i].rbeg;
	}
	f->ur_freebeg = nzcnt;

	nzcnt = 0;
	for (i = 0; i < dim; i++)
	{
		uc_inf[i].cbeg = nzcnt;
		nzcnt += uc_inf[i].nzcnt;
		uc_inf[i].nzcnt = uc_inf[i].cbeg;
	}
	f->uc_freebeg = nzcnt;

	f->lc_freebeg = 0;

	rval = 0;
CLEANUP:
	EG_RETURN (rval);
}

static int init_matrix (
	dbl_factor_work * f,
	int *basis,
	int *cbeg,
	int *clen,
	int *in_ucindx,
	double * in_uccoef)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	dbl_ur_info *ur_inf = f->ur_inf;
	int dim = f->dim;
	int max_k = f->max_k;
	int *ucindx;
	int *urindx;
	double *urcoef;
	int nzcnt;
	int beg;
	int i;
	int j;
	int r;
	int rval = 0;
	double v;
	double max;

	dbl_EGlpNumInitVar (v);
	dbl_EGlpNumInitVar (max);

	for (i = 0; i < dim; i++)
	{
		ur_inf[i].nzcnt = 0;
	}
	for (i = 0; i < dim; i++)
	{
		nzcnt = clen[basis[i]];
		beg = cbeg[basis[i]];
		uc_inf[i].nzcnt = nzcnt;
		for (j = 0; j < nzcnt; j++)
		{
			r = in_ucindx[beg + j];
			ur_inf[r].nzcnt++;
		}
	}

	rval = create_factor_space (f);
	CHECKRVALG (rval, CLEANUP);

	urindx = f->urindx;
	ucindx = f->ucindx;
	urcoef = f->urcoef;

	for (i = 0; i < dim; i++)
	{
		nzcnt = clen[basis[i]];
		beg = cbeg[basis[i]];
		for (j = 0; j < nzcnt; j++)
		{
			dbl_EGlpNumCopy (v, in_uccoef[beg + j]);
			if (!(dbl_EGlpNumIsNeqZero (v, f->fzero_tol)))
				continue;
			r = in_ucindx[beg + j];
			ucindx[uc_inf[i].nzcnt++] = r;
			urindx[ur_inf[r].nzcnt] = i;
			dbl_EGlpNumCopy (urcoef[ur_inf[r].nzcnt], v);
			ur_inf[r].nzcnt++;
		}
	}

	for (i = 0; i < dim; i++)
	{
		uc_inf[i].nzcnt -= uc_inf[i].cbeg;
		ur_inf[i].nzcnt -= ur_inf[i].rbeg;
	}

	j = f->uc_space;
	for (i = f->uc_freebeg; i < j; i++)
	{
		ucindx[i] = -1;
	}
	ucindx[j] = 0;

	j = f->ur_space;
	for (i = f->ur_freebeg; i < j; i++)
	{
		urindx[i] = -1;
	}
	urindx[j] = 0;

	for (i = 0; i < dim; i++)
	{
		nzcnt = ur_inf[i].nzcnt;
		ur_inf[i].pivcnt = nzcnt;
		beg = ur_inf[i].rbeg;
		dbl_EGlpNumZero (max);
		for (j = 0; j < nzcnt; j++)
		{
			dbl_EGlpNumSetToMaxAbs (max, urcoef[beg + j]);
		}
		dbl_EGlpNumCopy (ur_inf[i].max, max);
	}

	for (i = 0; i <= max_k; i++)
	{
		ur_inf[dim + i].next = dim + i;
		ur_inf[dim + i].prev = dim + i;
		uc_inf[dim + i].next = dim + i;
		uc_inf[dim + i].prev = dim + i;
	}

	for (i = 0; i < dim; i++)
	{
		nzcnt = uc_inf[i].nzcnt;
		if (nzcnt >= max_k)
			nzcnt = max_k;
		uc_inf[i].next = uc_inf[dim + nzcnt].next;
		uc_inf[i].prev = dim + nzcnt;
		uc_inf[dim + nzcnt].next = i;
		uc_inf[uc_inf[i].next].prev = i;

		nzcnt = ur_inf[i].pivcnt;
		if (nzcnt >= max_k)
			nzcnt = max_k;
		ur_inf[i].next = ur_inf[dim + nzcnt].next;
		ur_inf[i].prev = dim + nzcnt;
		ur_inf[dim + nzcnt].next = i;
		ur_inf[ur_inf[i].next].prev = i;
	}

#ifdef TRACK_FACTOR
	dbl_EGlpNumZero (max);
	nzcnt = 0;
	for (i = 0; i < dim; i++)
	{
		if (dbl_EGlpNumIsLess (max, ur_inf[i].max))
			dbl_EGlpNumCopy (max, ur_inf[i].max);
		nzcnt += ur_inf[i].nzcnt;
	}

	dbl_EGlpNumCopy (f->maxelem_orig, max);
	f->nzcnt_orig = nzcnt;
	dbl_EGlpNumCopy (f->maxelem_factor, f->maxelem_orig);
	f->nzcnt_factor = f->nzcnt_orig;
#endif /* TRACK_FACTOR */

	/* sentinal for column space */
	ucindx[f->uc_space] = 0;

	clear_work (f);

CLEANUP:
	dbl_EGlpNumClearVar (max);
	dbl_EGlpNumClearVar (v);
	EG_RETURN (rval);
}

static int build_iteration_u_data (
	dbl_factor_work * f)
{
	int dim = f->dim;
	dbl_ur_info *ur_inf = f->ur_inf;
	dbl_uc_info *uc_inf = f->uc_inf;
	double *uccoef = 0;
	int *ucindx = 0;
	int *urindx = f->urindx;
	double *urcoef = f->urcoef;
	int *ucrind = 0;
	int *urcind = 0;
	int nzcnt;
	int beg;
	int cbeg;
	int cnzcnt;
	int uc_space = f->uc_space;
	int er_space;
	int i;
	int j;
	int k;
	int rval;

	nzcnt = 0;
	for (i = 0; i < dim; i++)
	{
		nzcnt += ur_inf[i].nzcnt;
	}

#ifdef TRACK_FACTOR
	f->nzcnt_factor = nzcnt;
#endif /* TRACK_FACTOR */

	dbl_EGlpNumFreeArray (f->uccoef);
	uccoef = dbl_EGlpNumAllocArray (nzcnt);
	f->uccoef = uccoef;

	ILL_IFFREE(f->ucrind);
	ILL_SAFE_MALLOC (ucrind, nzcnt, int);

	f->ucrind = ucrind;

	ILL_IFFREE(f->urcind);
	ILL_SAFE_MALLOC (urcind, f->ur_space, int);

	f->urcind = urcind;

	if (uc_space < nzcnt)
	{
		ILL_IFFREE(f->ucindx);
		ILL_SAFE_MALLOC (f->ucindx, nzcnt + 1, int);
	}
	f->uc_space = nzcnt;
	uc_space = nzcnt;
	ucindx = f->ucindx;

	for (i = 0; i < dim; i++)
	{
		uc_inf[i].nzcnt = 0;
	}

	for (i = 0; i < dim; i++)
	{
		nzcnt = ur_inf[i].nzcnt;
		beg = ur_inf[i].rbeg;
		for (j = 0; j < nzcnt; j++)
		{
			uc_inf[urindx[beg + j]].nzcnt++;
		}
		ur_inf[i].delay = 0;
	}

	nzcnt = 0;
	for (i = 0; i < dim; i++)
	{
		uc_inf[i].cbeg = nzcnt;
		nzcnt += uc_inf[i].nzcnt;
		uc_inf[i].nzcnt = 0;
		uc_inf[i].delay = 0;
	}

	f->uc_freebeg = nzcnt;
	for (i = nzcnt; i < uc_space; i++)
	{
		ucindx[i] = -1;
	}
	ucindx[uc_space] = 0;

	for (i = 0; i < dim; i++)
	{
		nzcnt = ur_inf[i].nzcnt;
		beg = ur_inf[i].rbeg;
		k = urindx[beg];
		cbeg = uc_inf[k].cbeg;
		cnzcnt = uc_inf[k].nzcnt;
		if (cnzcnt != 0)
		{
			ucindx[cbeg + cnzcnt] = ucindx[cbeg];
			dbl_EGlpNumCopy (uccoef[cbeg + cnzcnt], uccoef[cbeg]);
			ucrind[cbeg + cnzcnt] = ucrind[cbeg];
			urcind[ur_inf[ucindx[cbeg]].rbeg + ucrind[cbeg]] = cnzcnt;
		}
		ucindx[cbeg] = i;
		dbl_EGlpNumCopy (uccoef[cbeg], urcoef[beg]);
		ucrind[cbeg] = 0;
		urcind[beg] = 0;
		uc_inf[k].nzcnt = cnzcnt + 1;
		for (j = 1; j < nzcnt; j++)
		{
			k = urindx[beg + j];
			cbeg = uc_inf[k].cbeg;
			cnzcnt = uc_inf[k].nzcnt;
			ucindx[cbeg + cnzcnt] = i;
			dbl_EGlpNumCopy (uccoef[cbeg + cnzcnt], urcoef[beg + j]);
			ucrind[cbeg + cnzcnt] = j;
			urcind[beg + j] = cnzcnt;
			uc_inf[k].nzcnt++;
		}
	}

	for (i = 0; i < dim; i++)
	{
		f->rrank[f->rperm[i]] = i;
	}

	nzcnt = f->ur_space;

	for (i = f->ur_freebeg; i < nzcnt; i++)
	{
		urindx[i] = -1;
	}
	urindx[nzcnt] = 0;

	clear_work (f);

	er_space = f->er_space_mul * f->etamax;
	ILL_SAFE_MALLOC (f->er_inf, f->etamax, dbl_er_info);
	ILL_SAFE_MALLOC (f->erindx, er_space, int);

	f->ercoef = dbl_EGlpNumAllocArray (er_space);
	f->etacnt = 0;
	f->er_freebeg = 0;
	f->er_space = er_space;

	rval = 0;

CLEANUP:
	EG_RETURN (rval);
}

static int build_iteration_l_data (
	dbl_factor_work * f)
{
	int dim = f->dim;
	dbl_lc_info *lc_inf = f->lc_inf;
	dbl_lr_info *lr_inf = f->lr_inf;
	double *lrcoef = 0;
	int *lrindx = 0;
	double *lccoef = f->lccoef;
	int *lcindx = f->lcindx;
	int nzcnt;
	int beg;
	int rnzcnt;
	int rbeg;
	int i;
	int j;
	int k;
	int c;
	int rval;

	nzcnt = 0;
	for (i = 0; i < dim; i++)
	{
		nzcnt += lc_inf[i].nzcnt;
		lr_inf[i].nzcnt = 0;
		lr_inf[i].delay = 0;
		lc_inf[lc_inf[i].c].crank = i;
	}

	dbl_EGlpNumFreeArray (f->lrcoef);
	if (nzcnt)
	{
		lrcoef = dbl_EGlpNumAllocArray (nzcnt);
		f->lrcoef = lrcoef;
	}

	ILL_IFFREE(f->lrindx);
	ILL_SAFE_MALLOC (lrindx, nzcnt + 1, int);

	f->lrindx = lrindx;

	for (i = 0; i < dim; i++)
	{
		nzcnt = lc_inf[i].nzcnt;
		beg = lc_inf[i].cbeg;
		lc_inf[i].delay = 0;
		for (j = 0; j < nzcnt; j++)
		{
			lr_inf[lc_inf[lcindx[beg + j]].crank].nzcnt++;
		}
	}

	nzcnt = 0;
	for (i = 0; i < dim; i++)
	{
		lr_inf[i].rbeg = nzcnt;
		nzcnt += lr_inf[i].nzcnt;
		lr_inf[i].nzcnt = 0;
		lr_inf[i].r = lc_inf[i].c;
		lr_inf[lr_inf[i].r].rrank = i;
	}

	for (i = 0; i < dim; i++)
	{
		nzcnt = lc_inf[i].nzcnt;
		beg = lc_inf[i].cbeg;
		c = lc_inf[i].c;
		for (j = 0; j < nzcnt; j++)
		{
			k = lc_inf[lcindx[beg + j]].crank;
			rbeg = lr_inf[k].rbeg;
			rnzcnt = lr_inf[k].nzcnt;
			lrindx[rbeg + rnzcnt] = c;
			dbl_EGlpNumCopy (lrcoef[rbeg + rnzcnt], lccoef[beg + j]);
			lr_inf[k].nzcnt++;
		}
	}

#ifdef TRACK_FACTOR
	nzcnt = f->nzcnt_factor;
	for (i = 0; i < dim; i++)
	{
		nzcnt += lc_inf[i].nzcnt;
	}
	f->nzcnt_factor = nzcnt;

	dbl_EGlpNumCopy (f->maxelem_cur, f->maxelem_factor);
	f->nzcnt_cur = f->nzcnt_factor;

/*
    dump_factor_stats (f);
    QSlog("orig max  %e nzcnt %d", f->maxelem_orig, f->nzcnt_orig);
    QSlog("f maxelem %e nzcnt %d", f->maxelem_cur, f->nzcnt_cur);
*/
#endif /* TRACK_FACTOR */

	rval = 0;

CLEANUP:
	EG_RETURN (rval);
}

static int handle_singularity (
	dbl_factor_work * f)
{
	int rval = 0;
	int nsing;
	int *singr = 0;
	int *singc = 0;
	int i;

	if (f->p_nsing == 0 || f->p_singr == 0 || f->p_singc == 0)
	{
		QSlog("singular basis, but no place for singularity data");
		return E_SING_NO_DATA;
	}

	nsing = f->nstages - f->stage;
	ILL_SAFE_MALLOC (singr, nsing, int);
	ILL_SAFE_MALLOC (singc, nsing, int);

	for (i = f->stage; i < f->nstages; i++)
	{
		singr[i - f->stage] = f->rperm[i];
		singc[i - f->stage] = f->cperm[i];
	}
	*f->p_nsing = nsing;
	*f->p_singr = singr;
	*f->p_singc = singc;
	singr = 0;
	singc = 0;

CLEANUP:
	ILL_IFFREE(singr);
	ILL_IFFREE(singc);

	EG_RETURN (rval);
}

static int dense_build_matrix (
	dbl_factor_work * f)
{
	double *dmat = 0;
	int stage = f->stage;
	int drows = f->nstages - stage;
	int dcols = f->dim - stage;
	int dsize = drows * dcols;
	int *crank = f->crank;
	double *urcoef = f->urcoef;
	int *urindx = f->urindx;
	int nzcnt;
	int beg;
	int i;
	int r;
	int j;
	int rval = 0;

	dmat = dbl_EGlpNumAllocArray (dsize);

	for (i = 0; i < dsize; i++)
		dbl_EGlpNumZero (dmat[i]);

	for (i = 0; i < drows; i++)
	{
		r = f->rperm[i + stage];
		nzcnt = f->ur_inf[r].nzcnt;
		beg = f->ur_inf[r].rbeg;
		for (j = 0; j < nzcnt; j++)
		{
			dbl_EGlpNumCopy (dmat[i * dcols - stage + crank[urindx[beg + j]]],
									 urcoef[beg + j]);
		}
	}

	f->drows = drows;
	f->dcols = dcols;
	f->dense_base = f->stage;
	f->dmat = dmat;
	dmat = 0;

//CLEANUP:
	dbl_EGlpNumFreeArray (dmat);
	EG_RETURN (rval);
}

static int dense_find_pivot (
	dbl_factor_work * f,
	int *p_r,
	int *p_c)
{
	int dcols = f->dcols;
	int drows = f->drows;
	double *dmat = f->dmat;
	int dense_base = f->dense_base;
	int s = f->stage - dense_base;
	dbl_ur_info *ur_inf = f->ur_inf;
	int *rperm = f->rperm;
	double maxval;
	int max_r;
	int max_c;
	int i;

	dbl_EGlpNumInitVar (maxval);
	dbl_EGlpNumZero (maxval);
	max_r = -1;
	for (i = s; i < drows; i++)
	{
		if (dbl_EGlpNumIsLess (maxval, ur_inf[rperm[dense_base + i]].max))
		{
			dbl_EGlpNumCopy (maxval, ur_inf[rperm[dense_base + i]].max);
			max_r = i;
		}
	}
	if (max_r == -1)
	{
		return E_NO_PIVOT;
	}

	dbl_EGlpNumZero (maxval);
	max_c = -1;
	for (i = s; i < drows; i++)
	{
		EGlpNumSetToMaxAbsAndDo (maxval, dmat[max_r * dcols + i], max_c = i);
	}
	if (max_c == -1)
	{
		return E_NO_PIVOT;
	}
	*p_r = max_r;
	*p_c = max_c;

	dbl_EGlpNumClearVar (maxval);
	return 0;
}

static void dense_swap (
	dbl_factor_work * f,
	int r,
	int c)
{
	int dcols = f->dcols;
	int drows = f->drows;
	double *dmat = f->dmat;
	int dense_base = f->dense_base;
	int s = f->stage - dense_base;
	int i;
	double v;

	dbl_EGlpNumInitVar (v);

	if (r != s)
	{
		ILL_SWAP (f->rperm[dense_base + s], f->rperm[dense_base + r], i);
		f->rrank[f->rperm[dense_base + s]] = dense_base + s;
		f->rrank[f->rperm[dense_base + r]] = dense_base + r;
		for (i = 0; i < dcols; i++)
		{
			dbl_EGLPNUM_SWAP (dmat[s * dcols + i], dmat[r * dcols + i], v);
		}
	}
	if (c != s)
	{
		ILL_SWAP (f->cperm[dense_base + s], f->cperm[dense_base + c], i);
		f->crank[f->cperm[dense_base + s]] = dense_base + s;
		f->crank[f->cperm[dense_base + c]] = dense_base + c;
		for (i = 0; i < drows; i++)
		{
			dbl_EGLPNUM_SWAP (dmat[i * dcols + s], dmat[i * dcols + c], v);
		}
	}
	dbl_EGlpNumClearVar (v);
}

static void dense_elim (
	dbl_factor_work * f,
	int r,
	int c)
{
	int dcols = f->dcols;
	int drows = f->drows;
	double *dmat = f->dmat;
	int dense_base = f->dense_base;
	int s = f->stage - dense_base;
	dbl_ur_info *ur_inf = f->ur_inf;
	int *rperm = f->rperm;
	int i;
	int j;
	double pivval;
	double max;
	double v;
	double w;

#ifdef TRACK_FACTOR
	double maxelem_factor;

	dbl_EGlpNumInitVar (maxelem_factor);
	dbl_EGlpNumCopy (maxelem_factor, f->maxelem_factor);
#endif
	dbl_EGlpNumInitVar (pivval);
	dbl_EGlpNumInitVar (max);
	dbl_EGlpNumInitVar (v);
	dbl_EGlpNumInitVar (w);

	dense_swap (f, r, c);
	f->stage++;
	dbl_EGlpNumCopyFrac (pivval, dbl_oneLpNum, dmat[s * dcols + s]);
	for (i = s + 1; i < drows; i++)
	{
		dbl_EGlpNumCopy (v, dmat[i * dcols + s]);
		if (dbl_EGlpNumIsNeqqZero (v))
		{
			dbl_EGlpNumMultTo (v, pivval);
			if (dbl_EGlpNumIsNeqZero (v, f->fzero_tol))
			{
				dbl_EGlpNumCopy (dmat[i * dcols + s], v);
#ifdef TRACK_FACTOR
				dbl_EGlpNumSetToMaxAbs (maxelem_factor, v);
#endif
				dbl_EGlpNumZero (max);
				for (j = s + 1; j < drows; j++)
				{
					dbl_EGlpNumCopy (w, dmat[i * dcols + j]);
					dbl_EGlpNumSubInnProdTo (w, v, dmat[s * dcols + j]);
					dbl_EGlpNumCopy (dmat[i * dcols + j], w);
					dbl_EGlpNumSetToMaxAbs (max, w);
				}
				for (j = drows; j < dcols; j++)
				{
					dbl_EGlpNumCopy (w, dmat[i * dcols + j]);
					dbl_EGlpNumSubInnProdTo (w, v, dmat[s * dcols + j]);
					dbl_EGlpNumCopy (dmat[i * dcols + j], w);
				}
				dbl_EGlpNumCopy (ur_inf[rperm[dense_base + i]].max, max);
#ifdef TRACK_FACTOR
				if (dbl_EGlpNumIsLess (maxelem_factor, max))
					dbl_EGlpNumCopy (maxelem_factor, max);
#endif
			}
			else
			{
				dbl_EGlpNumZero (dmat[i * dcols + s]);
			}
		}
	}
#ifdef TRACK_FACTOR
	dbl_EGlpNumCopy (f->maxelem_factor, maxelem_factor);
	dbl_EGlpNumClearVar (maxelem_factor);
#endif
	dbl_EGlpNumClearVar (pivval);
	dbl_EGlpNumClearVar (max);
	dbl_EGlpNumClearVar (v);
	dbl_EGlpNumClearVar (w);
}

static int dense_replace_row (
	dbl_factor_work * f,
	int i)
{
	int dcols = f->dcols;
	int dense_base = f->dense_base;
	double *dmat = f->dmat + i * dcols;
	double *urcoef;
	dbl_ur_info *ur_inf = f->ur_inf;
	int *cperm = f->cperm;
	int r = f->rperm[dense_base + i];
	int *urindx;
	int nzcnt;
	int beg;
	int j;
	int rval = 0;

	nzcnt = 0;
	for (j = i; j < dcols; j++)
	{
		if (dbl_EGlpNumIsNeqZero (dmat[j], f->fzero_tol))
		{
			nzcnt++;
		}
	}
	if (nzcnt > ur_inf[r].nzcnt)
	{
		if (ur_inf[r].rbeg + ur_inf[r].nzcnt == f->ur_freebeg)
		{
			f->ur_freebeg = ur_inf[r].rbeg;
		}
		ur_inf[r].nzcnt = 0;
		if (f->ur_freebeg + nzcnt > f->ur_space)
		{
			rval = make_ur_space (f, nzcnt);
			CHECKRVALG (rval, CLEANUP);
		}
		ur_inf[r].rbeg = f->ur_freebeg;
		f->ur_freebeg += nzcnt;
	}
	beg = ur_inf[r].rbeg;
	urcoef = f->urcoef;
	urindx = f->urindx;
	for (j = i; j < dcols; j++)
	{
		if (dbl_EGlpNumIsNeqZero (dmat[j], f->fzero_tol))
		{
			dbl_EGlpNumCopy (urcoef[beg], dmat[j]);
			urindx[beg] = cperm[dense_base + j];
			beg++;
		}
	}
	ur_inf[r].nzcnt = beg - ur_inf[r].rbeg;
CLEANUP:
	EG_RETURN (rval);
}

static int dense_create_col (
	dbl_factor_work * f,
	int i)
{
	int dcols = f->dcols;
	int drows = f->drows;
	int dense_base = f->dense_base;
	double *dmat = f->dmat;
	double *lccoef;
	dbl_lc_info *lc_inf = f->lc_inf;
	int *rperm = f->rperm;
	int *lcindx;
	int nzcnt;
	int beg;
	int j;
	int rval = 0;

	nzcnt = 0;
	for (j = i + 1; j < drows; j++)
	{
		if (dbl_EGlpNumIsNeqZero (dmat[j * dcols + i], f->fzero_tol))
		{
			nzcnt++;
		}
	}

	if (f->lc_freebeg + nzcnt >= f->lc_space)
	{
		rval = make_lc_space (f, nzcnt);
		CHECKRVALG (rval, CLEANUP);
	}
	beg = f->lc_freebeg;
	lc_inf[dense_base + i].cbeg = beg;
	lc_inf[dense_base + i].c = rperm[dense_base + i];
	lcindx = f->lcindx;
	lccoef = f->lccoef;

	for (j = i + 1; j < drows; j++)
	{
		if (dbl_EGlpNumIsNeqZero (dmat[j * dcols + i], f->fzero_tol))
		{
			dbl_EGlpNumCopy (lccoef[beg], dmat[j * dcols + i]);
			lcindx[beg] = rperm[dense_base + j];
			beg++;
		}
	}
	lc_inf[dense_base + i].nzcnt = beg - lc_inf[dense_base + i].cbeg;
	f->lc_freebeg = beg;
CLEANUP:
	EG_RETURN (rval);
}

static int dense_replace (
	dbl_factor_work * f)
{
	int drows = f->drows;
	int rval = 0;
	int i;

	for (i = 0; i < drows; i++)
	{
		rval = dense_replace_row (f, i);
		CHECKRVALG (rval, CLEANUP);
		rval = dense_create_col (f, i);
		CHECKRVALG (rval, CLEANUP);
	}
	dbl_EGlpNumFreeArray (f->dmat);
	f->drows = 0;
	f->dcols = 0;
CLEANUP:
	EG_RETURN (rval);
}

static int dense_factor (
	dbl_factor_work * f)
{
	int r;
	int c;
	int rval = 0;

#ifdef TRACK_FACTOR
#ifdef NOTICE_BLOWUP
	double tmpsize;
#endif
#endif

/*
    QSlog("dense kernel, %d rows, %d  cols...", f->nstages - f->stage,
		            f->dim - f->stage);
*/

	rval = dense_build_matrix (f);
	CHECKRVALG (rval, CLEANUP);

#ifdef FACTOR_DEBUG
#if (FACTOR_DEBUG+0>1)
	MESSAGE (0,"before Dense dbl_ILLfactor");
	dump_matrix (f, 1);
#endif
#endif

	while (f->stage < f->nstages)
	{
		r = f->stage - f->dense_base;
		rval = dense_find_pivot (f, &r, &c);
		if (rval == E_NO_PIVOT)
		{
			rval = handle_singularity (f);
			CHECKRVALG (rval, CLEANUP);
			return E_SINGULAR_INTERNAL;
		}
		else
		{
			CHECKRVALG (rval, CLEANUP);
		}
#ifdef FACTOR_DEBUG
#if (FACTOR_DEBUG+0>2)
		MESSAGE (0,"dense pivot elem: %d %d", r, c);
#endif
#endif /* FACTOR_DEBUG */
		dense_elim (f, r, c);

#ifdef TRACK_FACTOR
#ifdef NOTICE_BLOWUP
		tmpsize = f->maxmult * dbl_EGlpNumToLf (f->maxelem_orig);
		if (tmpsize < dbl_EGlpNumToLf (f->maxelem_factor) &&
				dbl_EGlpNumIsLess (f->partial_cur, dbl_oneLpNum))
		{
			return E_FACTOR_BLOWUP;
		}
#endif /* NOTICE_BLOWUP */
#endif /* TRACK_FACTOR */

#ifdef FACTOR_DEBUG
#if (FACTOR_DEBUG+0>1)
		MESSAGE (0,"After dense pivot stage %d (%d) of %d (%d)",
						f->stage - f->dense_base, f->stage,
						f->nstages - f->dense_base, f->nstages);
#endif
#if (FACTOR_DEBUG+0>2)
		dump_matrix (f, 1);
#endif
#endif /* FACTOR_DEBUG */
	}

#ifdef FACTOR_DEBUG
	MESSAGE (0,"After dense dbl_ILLfactor:\n");
	dump_matrix (f, 0);
#endif /* FACTOR_DEBUG */

	rval = dense_replace (f);
	CHECKRVALG (rval, CLEANUP);

#ifdef FACTOR_DEBUG
	MESSAGE (0,"After replacement:\n");
	dump_matrix (f, 0);
#endif /* FACTOR_DEBUG */

CLEANUP:
	EG_RETURN (rval);
}

#ifdef RECORD
EGioFile_t *fsave = 0;
int fsavecnt = 0;
#endif /* RECORD */

static int ILLfactor_try (
	dbl_factor_work * f,
	int *basis,
	int *cbeg,
	int *clen,
	int *cindx,
	double * ccoef)
{
	int rval = 0;
	int r;
	int c;

#ifdef TRACK_FACTOR
#ifdef NOTICE_BLOWUP
	double tmpsize;

	dbl_EGlpNumInitVar (tmpsize);
#endif
#endif

#ifdef RECORD
	{
		int ncol = 0;
		int nzcnt = 0;
		int dim = f->dim;
		int i;
		int j;
		char fnambuf[40];

		for (i = 0; i < dim; i++)
		{
			if (basis[i] > ncol)
				ncol = basis[i];
		}
		ncol++;
		for (i = 0; i < ncol; i++)
		{
			nzcnt += clen[i];
		}
		if (fsave)
			EGioClose (fsave);
#if HAVE_LIBZ
		sprintf (fnambuf, "prob.mat.%d.gz", fsavecnt);
#elif HAVE_LIBBZ2
		sprintf (fnambuf, "prob.mat.%d.bz2", fsavecnt);
#else
		sprintf (fnambuf, "prob.mat.%d", fsavecnt);
#endif
		fsavecnt++;
		fsave = EGioOpen (fnambuf, "w");
		EGioPrintf (fsave, "%d %d %d\n", f->dim, ncol, nzcnt);
		for (i = 0; i < dim; i++)
		{
			EGioPrintf (fsave, "%d ", basis[i]);
		}
		EGioPrintf (fsave, "\n");
		for (i = 0; i < ncol; i++)
		{
			EGioPrintf (fsave, "%d", clen[i]);
			for (j = 0; j < clen[i]; j++)
			{
				EGioPrintf (fsave, " %d %.16lg", cindx[cbeg[i] + j],
								 dbl_EGlpNumToLf (ccoef[cbeg[i] + j]));
			}
			EGioPrintf (fsave, "\n");
		}
		EGioPrintf (fsave, "\n");
		EGioFlush (fsave);
	}
#endif /* RECORD */

	rval = init_matrix (f, basis, cbeg, clen, cindx, ccoef);
	CHECKRVALG (rval, CLEANUP);

	f->stage = 0;
	f->nstages = f->dim;

#ifdef FACTOR_DEBUG
	MESSAGE (0,"Initial matrix:");
#if (FACTOR_DEBUG+0>1)
	dump_matrix (f, 0);
#endif
#endif /* FACTOR_DEBUG */
#ifdef FACTOR_STATS
	QSlog("Initial matrix: ");
	dump_factor_stats (f);
#endif /* FACTOR_STATS */

	while (f->stage < f->nstages)
	{
		rval = find_pivot (f, &r, &c);
		if (rval == E_NO_PIVOT)
		{
			rval = handle_singularity (f);
			CHECKRVALG (rval, CLEANUP);
			return 0;
		}
		else
		{
			CHECKRVALG (rval, CLEANUP);
		}
		if (f->ur_inf[r].pivcnt > f->dense_fract * (f->nstages - f->stage) &&
				f->uc_inf[c].nzcnt > f->dense_fract * (f->nstages - f->stage) &&
				f->nstages - f->stage > f->dense_min)
		{
			rval = dense_factor (f);
			if (rval == E_SINGULAR_INTERNAL)
				return 0;
			if (rval)
				return rval;
			break;
		}
#ifdef FACTOR_DEBUG
		MESSAGE (0,"pivot elem: %d %d", r, c);
#endif /* FACTOR_DEBUG */
		rval = elim (f, r, c);
		CHECKRVALG (rval, CLEANUP);

#ifdef TRACK_FACTOR
#ifdef NOTICE_BLOWUP
		dbl_EGlpNumSet (tmpsize, f->maxmult);
		dbl_EGlpNumMultTo (tmpsize, f->maxelem_orig);
		if (dbl_EGlpNumIsLess (tmpsize, f->maxelem_factor) &&
				dbl_EGlpNumIsLess (f->partial_cur, dbl_oneLpNum))
		{
			return E_FACTOR_BLOWUP;
		}
#endif /* NOTICE_BLOWUP */
#endif /* TRACK_FACTOR */

#ifdef FACTOR_DEBUG
#if (FACTOR_DEBUG+0>3)
		MESSAGE (0,"After pivot stage %d of %d", f->stage, f->nstages);
		dump_matrix (f, 0);
#endif
#endif /* FACTOR_DEBUG */
	}

	rval = build_iteration_u_data (f);
	CHECKRVALG (rval, CLEANUP);

	rval = build_iteration_l_data (f);
	CHECKRVALG (rval, CLEANUP);

#ifdef TRACK_FACTOR
#ifdef NOTICE_BLOWUP
	dbl_EGlpNumSet (tmpsize, f->minmult);
	dbl_EGlpNumMultTo (tmpsize, f->maxelem_orig);
	if (dbl_EGlpNumIsLess (f->maxelem_factor, tmpsize) &&
			dbl_EGlpNumIsLess (f->partial_tol, f->partial_cur))
	{
		if (dbl_EGlpNumIsGreaDbl (f->partial_cur, 0.5))
		{
			dbl_EGlpNumSet (f->partial_cur, 0.5);
		}
		else if (dbl_EGlpNumIsGreaDbl (f->partial_cur, 0.25))
		{
			dbl_EGlpNumSet (f->partial_cur, 0.25);
		}
		else if (dbl_EGlpNumIsGreaDbl (f->partial_cur, 0.1))
		{
			dbl_EGlpNumSet (f->partial_cur, 0.1);
		}
		else
		{
			dbl_EGlpNumDivUiTo (f->partial_cur, 10);
		}
		if (dbl_EGlpNumIsLess (f->partial_cur, f->partial_tol))
		{
			dbl_EGlpNumCopy (f->partial_cur, f->partial_tol);
		}
/*  Bico - comment out for dist 
        QSlog("factor good, lowering partial tolerance to %.2f",
                    f->partial_cur);
*/
	}
#endif /* NOTICE_BLOWUP */
#endif /* TRACK_FACTOR */

#ifdef FACTOR_DEBUG
	MESSAGE(0,"Factored matrix:");
#if (FACTOR_DEBUG+0>1)
	dump_matrix (f, 0);
#endif
#endif /* FACTOR_DEBUG */

#ifdef FACTOR_STATS
	QSlog("Factored matrix: ");
	dump_factor_stats (f);
#endif /* FACTOR_STATS */
CLEANUP:
#ifdef TRACK_FACTOR
#ifdef NOTICE_BLOWUP
	dbl_EGlpNumClearVar (tmpsize);
#endif
#endif
	EG_RETURN (rval);
}

int dbl_ILLfactor (
	dbl_factor_work * f,
	int *basis,
	int *cbeg,
	int *clen,
	int *cindx,
	double * ccoef,
	int *p_nsing,
	int **p_singr,
	int **p_singc)
{
	int rval;

	f->p_nsing = p_nsing;
	f->p_singr = p_singr;
	f->p_singc = p_singc;
	*p_nsing = 0;

AGAIN:
	rval = ILLfactor_try (f, basis, cbeg, clen, cindx, ccoef);
	if (rval == E_FACTOR_BLOWUP)
	{
		if (dbl_EGlpNumIsLessDbl (f->partial_cur, 0.1))
		{
			dbl_EGlpNumMultUiTo (f->partial_cur, 10);
		}
		else if (dbl_EGlpNumIsLessDbl (f->partial_cur, 0.25))
		{
			dbl_EGlpNumSet (f->partial_cur, 0.25);
		}
		else if (dbl_EGlpNumIsLessDbl (f->partial_cur, 0.5))
		{
			dbl_EGlpNumSet (f->partial_cur, 0.5);
		}
		else if (dbl_EGlpNumIsLess (f->partial_cur, dbl_oneLpNum))
		{
			dbl_EGlpNumOne (f->partial_cur);
		}
		else
		{
			EG_RETURN (rval);
		}
/* Bico - comment out for dist
        QSlog("factor blowup, changing partial tolerance to %.2f",
                    f->partial_cur);
*/
		goto AGAIN;
	}
	EG_RETURN (rval);
}

static void ILLfactor_ftranl (
	dbl_factor_work * f,
	double * a)
{
	int *lcindx = f->lcindx;
	dbl_lc_info *lc_inf = f->lc_inf;
	double *lccoef = f->lccoef;
	int dim = f->dim;
	int beg;
	int nzcnt;
	int i;
	int j;
	double v;

	dbl_EGlpNumInitVar (v);

	for (i = 0; i < dim; i++)
	{
		dbl_EGlpNumCopy (v, a[lc_inf[i].c]);
		if (dbl_EGlpNumIsNeqqZero (v))
		{
			nzcnt = lc_inf[i].nzcnt;
			beg = lc_inf[i].cbeg;
			for (j = 0; j < nzcnt; j++)
			{
				dbl_EGlpNumSubInnProdTo (a[lcindx[beg + j]], v, lccoef[beg + j]);
			}
		}
#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 > 1)
		QSlog("dbl_ILLfactor_ftran a after l %d:", i);
		for (j = 0; j < f->dim; j++)
		{
			QSlog(" %.3f", dbl_EGlpNumToLf (a[j]));
		}
		MESSAGE(0," ");
#endif
#endif /* SOLVE_DEBUG */
	}
#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 <= 1)
	QSlog("dbl_ILLfactor_ftran a after l:");
	for (j = 0; j < f->dim; j++)
	{
		QSlog(" %.3f", dbl_EGlpNumToLf (a[j]));
	}
#endif
#endif /* SOLVE_DEBUG */
	dbl_EGlpNumClearVar (v);
}

#if 0
static void ftranl3_delay (
	dbl_factor_work * f,
	int c)
{
	dbl_lc_info *lc_inf = f->lc_inf;
	int nzcnt;
	int *indx;
	int i;

	c = lc_inf[c].crank;
	nzcnt = lc_inf[c].nzcnt;
	indx = f->lcindx + lc_inf[c].cbeg;
	for (i = 0; i < nzcnt; i++)
	{
		c = indx[i];
		if (lc_inf[c].delay++ == 0)
		{
			ftranl3_delay (f, c);
		}
	}
}
#endif

static void ftranl3_delay2 (
	dbl_factor_work * f,
	int c)
{
	dbl_lc_info *lc_inf = f->lc_inf;
	int nzcnt;
	int *indx;
	int i;
	int last;

	do
	{
		c = lc_inf[c].crank;
		nzcnt = lc_inf[c].nzcnt;
		indx = f->lcindx + lc_inf[c].cbeg;
		last = -1;
		for (i = 0; i < nzcnt; i++)
		{
			c = indx[i];
			if (lc_inf[c].delay++ == 0)
			{
				if (last >= 0)
				{
					ftranl3_delay2 (f, last);
				}
				last = c;
			}
		}
		c = last;
	} while (c >= 0);
}

#if 0
static void ftranl3_process (
	dbl_factor_work * f,
	int c,
	dbl_svector * x)
{
	dbl_lc_info *lc_inf = f->lc_inf;
	double *work = f->work_coef;
	int nzcnt;
	int *indx;
	int i;
	double *coef;
	double v;

	dbl_EGlpNumInitVar (v);

	dbl_EGlpNumCopy (v, work[c]);
	dbl_EGlpNumZero (work[c]);
	if (dbl_EGlpNumIsNeqqZero (v))
	{
		x->indx[x->nzcnt] = c;
		dbl_EGlpNumCopy (x->coef[x->nzcnt], v);
		x->nzcnt++;
	}
	c = lc_inf[c].crank;
	nzcnt = lc_inf[c].nzcnt;
	indx = f->lcindx + lc_inf[c].cbeg;
	coef = f->lccoef + lc_inf[c].cbeg;
	for (i = 0; i < nzcnt; i++)
	{
		c = indx[i];
		dbl_EGlpNumSubInnProdTo (work[c], v, coef[i]);
		if (--lc_inf[c].delay == 0)
		{
			ftranl3_process (f, c, x);
		}
	}
	dbl_EGlpNumClearVar (v);
}
#endif

static void ftranl3_process2 (
	dbl_factor_work * f,
	int c,
	dbl_svector * x)
{
	dbl_lc_info *lc_inf = f->lc_inf;
	double *work = f->work_coef;
	int nzcnt;
	int *indx;
	double *coef;
	int i;
	int last;
	double v;

	dbl_EGlpNumInitVar (v);

	do
	{
		dbl_EGlpNumCopy (v, work[c]);
		dbl_EGlpNumZero (work[c]);
		if (dbl_EGlpNumIsNeqqZero (v))
		{
			x->indx[x->nzcnt] = c;
			dbl_EGlpNumCopy (x->coef[x->nzcnt], v);
			x->nzcnt++;
		}
		c = lc_inf[c].crank;
		nzcnt = lc_inf[c].nzcnt;
		indx = f->lcindx + lc_inf[c].cbeg;
		coef = f->lccoef + lc_inf[c].cbeg;
		last = -1;
		for (i = 0; i < nzcnt; i++)
		{
			c = indx[i];
			dbl_EGlpNumSubInnProdTo (work[c], v, coef[i]);
			if (--lc_inf[c].delay == 0)
			{
				if (last >= 0)
				{
					ftranl3_process2 (f, last, x);
				}
				last = c;
			}
		}
		c = last;
	} while (c >= 0);
	dbl_EGlpNumClearVar (v);
}

static void ILLfactor_ftranl3 (
	dbl_factor_work * f,
	dbl_svector * a,
	dbl_svector * x)
{
	double *work = f->work_coef;
	int anzcnt = a->nzcnt;
	int *aindx = a->indx;
	double *acoef = a->coef;
	dbl_lc_info *lc_inf = f->lc_inf;
	int i;

	for (i = 0; i < anzcnt; i++)
	{
		if (lc_inf[aindx[i]].delay++ == 0)
		{
			ftranl3_delay2 (f, aindx[i]);
		}
		dbl_EGlpNumCopy (work[aindx[i]], acoef[i]);
	}
	x->nzcnt = 0;
	for (i = 0; i < anzcnt; i++)
	{
		if (--lc_inf[aindx[i]].delay == 0)
		{
			ftranl3_process2 (f, aindx[i], x);
		}
	}
#ifdef SOLVE_DEBUG
	QSlog("dbl_ILLfactor_ftran x after l3:");
	for (i = 0; i < x->nzcnt; i++)
	{
		QSlog(" %.3f*%d", dbl_EGlpNumToLf (x->coef[i]), x->indx[i]);
	}
#endif /* SOLVE_DEBUG */
}

static void ILLfactor_ftrane (
	dbl_factor_work * f,
	double * a)
{
	int *erindx = f->erindx;
	double *ercoef = f->ercoef;
	dbl_er_info *er_inf = f->er_inf;
	int etacnt = f->etacnt;
	int beg;
	int nzcnt;
	int i;
	int j;
	double v;

	dbl_EGlpNumInitVar (v);

	for (i = 0; i < etacnt; i++)
	{
		dbl_EGlpNumCopy (v, a[er_inf[i].r]);
		nzcnt = er_inf[i].nzcnt;
		beg = er_inf[i].rbeg;
		for (j = 0; j < nzcnt; j++)
		{
			dbl_EGlpNumSubInnProdTo (v, ercoef[beg + j], a[erindx[beg + j]]);
		}
		dbl_EGlpNumCopy (a[er_inf[i].r], v);
#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 > 1)
		QSlog("dbl_ILLfactor_ftran a after eta %d:", i);
		for (j = 0; j < f->dim; j++)
		{
			QSlog(" %.3f", dbl_EGlpNumToLf (a[j]));
		}
#endif
#endif /* SOLVE_DEBUG */
	}
#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 <= 1)
	QSlog("dbl_ILLfactor_ftran a after eta:");
	for (j = 0; j < f->dim; j++)
	{
		QSlog(" %.3f", dbl_EGlpNumToLf (a[j]));
	}
#endif
#endif /* SOLVE_DEBUG */
	dbl_EGlpNumClearVar (v);
}

static void ILLfactor_ftrane2 (
	dbl_factor_work * f,
	dbl_svector * a)
{
	int *erindx = f->erindx;
	double *ercoef = f->ercoef;
	dbl_er_info *er_inf = f->er_inf;
	int etacnt = f->etacnt;
	int beg;
	int nzcnt;
	int anzcnt = a->nzcnt;
	int *aindx = a->indx;
	double *acoef = a->coef;
	double *work_coef = f->work_coef;
	int *work_indx = f->work_indx;
	int i;
	int j;
	int r;
	double v;

	dbl_EGlpNumInitVar (v);

	for (i = 0; i < anzcnt; i++)
	{
		dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
		work_indx[aindx[i]] = i + 1;
	}
	for (i = 0; i < etacnt; i++)
	{
		r = er_inf[i].r;
		dbl_EGlpNumCopy (v, work_coef[r]);
		nzcnt = er_inf[i].nzcnt;
		beg = er_inf[i].rbeg;
		for (j = 0; j < nzcnt; j++)
		{
			dbl_EGlpNumSubInnProdTo (v, ercoef[beg + j], work_coef[erindx[beg + j]]);
		}
		if (dbl_EGlpNumIsNeqqZero (v))
		{
			dbl_EGlpNumCopy (work_coef[r], v);
			if (work_indx[r] == 0)
			{
				dbl_EGlpNumCopy (acoef[anzcnt], v);
				aindx[anzcnt] = r;
				work_indx[r] = anzcnt + 1;
				anzcnt++;
			}
			else
			{
				dbl_EGlpNumCopy (acoef[work_indx[r] - 1], v);
			}
		}
		else
		{
			dbl_EGlpNumZero (work_coef[r]);
			if (work_indx[r])
			{
				dbl_EGlpNumZero (acoef[work_indx[r] - 1]);
			}
		}
#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 > 1)
		QSlog("dbl_ILLfactor_ftran a after eta2 %d:", i);
		for (j = 0; j < anzcnt; j++)
		{
			QSlog(" %.3f*%d", dbl_EGlpNumToLf (acoef[j]), aindx[j]);
		}
#endif
#endif /* SOLVE_DEBUG */
	}
	i = 0;
	while (i < anzcnt)
	{
		dbl_EGlpNumZero (work_coef[aindx[i]]);
		work_indx[aindx[i]] = 0;
		if (dbl_EGlpNumIsNeqZero (acoef[i], f->fzero_tol))
		{
			/*if (acoef[i] > fzero_tol || acoef[i] < -fzero_tol) */
			i++;
		}
		else
		{
			--anzcnt;
			dbl_EGlpNumCopy (acoef[i], acoef[anzcnt]);
			aindx[i] = aindx[anzcnt];
		}
	}
	a->nzcnt = anzcnt;

#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 <= 1)
	QSlog("dbl_ILLfactor_ftran a after eta2:");
	for (j = 0; j < anzcnt; j++)
	{
		QSlog(" %.3f*%d", dbl_EGlpNumToLf (acoef[j]), aindx[j]);
	}
#endif
#endif /* SOLVE_DEBUG */
	dbl_EGlpNumClearVar (v);
}

static void ILLfactor_ftranu (
	dbl_factor_work * f,
	double * a,
	dbl_svector * x)
{
	int *ucindx = f->ucindx;
	double *uccoef = f->uccoef;
	dbl_uc_info *uc_inf = f->uc_inf;
	int *cperm = f->cperm;
	int *rperm = f->rperm;
	int dim = f->dim;
	int xnzcnt = 0;
	int *xindx = x->indx;
	double *xcoef = x->coef;
	int nzcnt;
	int beg;
	int i;
	int j;
	double v;

	dbl_EGlpNumInitVar (v);

	for (i = dim - 1; i >= 0; i--)
	{
		dbl_EGlpNumCopy (v, a[rperm[i]]);
		if (dbl_EGlpNumIsNeqqZero (v))	/*((v = a[rperm[i]]) != 0.0) */
		{
			j = cperm[i];
			beg = uc_inf[j].cbeg;
			dbl_EGlpNumDivTo (v, uccoef[beg]);
			if (dbl_EGlpNumIsNeqZero (v, f->szero_tol))
			{
				/*if (v > szero_tol || v < -szero_tol) */
				xindx[xnzcnt] = j;
				dbl_EGlpNumCopy (xcoef[xnzcnt], v);
				xnzcnt++;
			}
			nzcnt = uc_inf[j].nzcnt;
			for (j = 1; j < nzcnt; j++)
			{
				dbl_EGlpNumSubInnProdTo (a[ucindx[beg + j]], v, uccoef[beg + j]);
			}
			dbl_EGlpNumZero (a[rperm[i]]);
		}
	}
	x->nzcnt = xnzcnt;
#ifdef SOLVE_DEBUG
	QSlog("dbl_ILLfactor_ftran x after u:");
	for (j = 0; j < x->nzcnt; j++)
	{
		QSlog(" %.3f*%d", dbl_EGlpNumToLf (x->coef[j]), x->indx[j]);
	}
#endif /* SOLVE_DEBUG */
	dbl_EGlpNumClearVar (v);
}


#if 0
static void ftranu3_delay (
	dbl_factor_work * f,
	int c)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	int nzcnt;
	int *indx;
	int i;

	c = f->cperm[f->rrank[c]];
	nzcnt = uc_inf[c].nzcnt;
	indx = f->ucindx + uc_inf[c].cbeg;
	for (i = 1; i < nzcnt; i++)
	{
		c = indx[i];
		if (uc_inf[c].delay++ == 0)
		{
			ftranu3_delay (f, c);
		}
	}
}
#endif

static void ftranu3_delay2 (
	dbl_factor_work * f,
	int c)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	int nzcnt;
	int *indx;
	int i;
	int last;

	do
	{
		c = f->cperm[f->rrank[c]];
		nzcnt = uc_inf[c].nzcnt;
		indx = f->ucindx + uc_inf[c].cbeg;
		last = -1;
		for (i = 1; i < nzcnt; i++)
		{
			c = indx[i];
			if (uc_inf[c].delay++ == 0)
			{
				if (last >= 0)
				{
					ftranu3_delay2 (f, last);
				}
				last = c;
			}
		}
		c = last;
	} while (c >= 0);
}

#if 0
static void ftranu3_process (
	dbl_factor_work * f,
	int c,
	dbl_svector * x)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	double *work = f->work_coef;
	int nzcnt;
	int *indx;
	double *coef;
	int i;
	double v;

	dbl_EGlpNumInitVar (v);

	dbl_EGlpNumCopy (v, work[c]);
	dbl_EGlpNumZero (work[c]);
	c = f->cperm[f->rrank[c]];
	nzcnt = uc_inf[c].nzcnt;
	indx = f->ucindx + uc_inf[c].cbeg;
	coef = f->uccoef + uc_inf[c].cbeg;
	dbl_EGlpNumDivTo (v, coef[0]);
	if (dbl_EGlpNumIsNeqZero (v, f->szero_tol))
		/*if (v > szero_tol || v < -szero_tol) */
	{
		x->indx[x->nzcnt] = c;
		dbl_EGlpNumCopy (x->coef[x->nzcnt], v);
		x->nzcnt++;
	}
	for (i = 1; i < nzcnt; i++)
	{
		c = indx[i];
		dbl_EGlpNumSubInnProdTo (work[c], v, coef[i]);
		if (--uc_inf[c].delay == 0)
		{
			ftranu3_process (f, c, x);
		}
	}
	dbl_EGlpNumClearVar (v);
}
#endif

static void ftranu3_process2 (
	dbl_factor_work * f,
	int c,
	dbl_svector * x)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	double *work = f->work_coef;
	int nzcnt;
	int *indx;
	double *coef;
	int i;
	int last;
	double v;

	dbl_EGlpNumInitVar (v);

	do
	{
		dbl_EGlpNumCopy (v, work[c]);
		dbl_EGlpNumZero (work[c]);
		c = f->cperm[f->rrank[c]];
		nzcnt = uc_inf[c].nzcnt;
		indx = f->ucindx + uc_inf[c].cbeg;
		coef = f->uccoef + uc_inf[c].cbeg;
		dbl_EGlpNumDivTo (v, coef[0]);
		if (dbl_EGlpNumIsNeqZero (v, f->szero_tol))
			/*if (v > szero_tol || v < -szero_tol) */
		{
			x->indx[x->nzcnt] = c;
			dbl_EGlpNumCopy (x->coef[x->nzcnt], v);
			x->nzcnt++;
		}
		last = -1;
		for (i = 1; i < nzcnt; i++)
		{
			c = indx[i];
			dbl_EGlpNumSubInnProdTo (work[c], v, coef[i]);
			if (--uc_inf[c].delay == 0)
			{
				if (last >= 0)
				{
					ftranu3_process2 (f, last, x);
				}
				last = c;
			}
		}
		c = last;
	} while (c >= 0);
	dbl_EGlpNumClearVar (v);
}

static void ILLfactor_ftranu3 (
	dbl_factor_work * f,
	dbl_svector * a,
	dbl_svector * x)
{
	double *work = f->work_coef;
	int anzcnt = a->nzcnt;
	int *aindx = a->indx;
	double *acoef = a->coef;
	dbl_uc_info *uc_inf = f->uc_inf;
	int i;

	for (i = 0; i < anzcnt; i++)
	{
		if (uc_inf[aindx[i]].delay++ == 0)
		{
			ftranu3_delay2 (f, aindx[i]);
		}
		dbl_EGlpNumCopy (work[aindx[i]], acoef[i]);
	}
	x->nzcnt = 0;
	for (i = 0; i < anzcnt; i++)
	{
		if (--uc_inf[aindx[i]].delay == 0)
		{
			ftranu3_process2 (f, aindx[i], x);
		}
	}
#ifdef SOLVE_DEBUG
	QSlog("dbl_ILLfactor_ftran x after u3:");
	for (i = 0; i < x->nzcnt; i++)
	{
		QSlog(" %.3f*%d", dbl_EGlpNumToLf (x->coef[i]), x->indx[i]);
	}
#endif /* SOLVE_DEBUG */
}

/* dbl_ILLfactor_ftran solves Bx=a for x */
void dbl_ILLfactor_ftran (
	dbl_factor_work * f,
	dbl_svector * a,
	dbl_svector * x)
{
	int i;
	int nzcnt;
	int sparse;
	int *aindx;
	double *acoef;
	double *work_coef = f->work_coef;

#ifdef RECORD
	{
		EGioPrintf (fsave, "f %d", a->nzcnt);
		for (i = 0; i < a->nzcnt; i++)
		{
			EGioPrintf (fsave, " %d %.16e", a->indx[i], dbl_EGlpNumToLf (a->coef[i]));
		}
		EGioPrintf (fsave, "\n");
		EGioFlush (fsave);
	}
#endif /* RECORD */
#ifdef DEBUG_FACTOR
	{
		QSlog("dbl_ILLfactor_ftran a:");
		for (i = 0; i < a->nzcnt; i++)
		{
			QSlog(" %d %la", a->indx[i], dbl_EGlpNumToLf (a->coef[i]));
		}
	}
#endif /* DEBUG_FACTOR */

	if (a->nzcnt >= SPARSE_FACTOR * f->dim)
	{
		nzcnt = a->nzcnt;
		aindx = a->indx;
		acoef = a->coef;
		for (i = 0; i < nzcnt; i++)
		{
			dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
		}
		sparse = 0;
	}
	else
	{
		sparse = 1;
	}

	if (sparse)
	{
		ILLfactor_ftranl3 (f, a, &f->xtmp);
		if (f->xtmp.nzcnt >= SPARSE_FACTOR * f->dim)
		{
			nzcnt = f->xtmp.nzcnt;
			aindx = f->xtmp.indx;
			acoef = f->xtmp.coef;

			for (i = 0; i < nzcnt; i++)
			{
				dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
			}
			sparse = 0;
		}
	}
	else
	{
		ILLfactor_ftranl (f, work_coef);
	}

	if (sparse)
	{
		ILLfactor_ftrane2 (f, &f->xtmp);
		if (f->xtmp.nzcnt >= SPARSE_FACTOR * f->dim)
		{
			nzcnt = f->xtmp.nzcnt;
			aindx = f->xtmp.indx;
			acoef = f->xtmp.coef;

			for (i = 0; i < nzcnt; i++)
			{
				dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
			}
			sparse = 0;
		}
	}
	else
	{
		ILLfactor_ftrane (f, work_coef);
	}

	if (sparse)
	{
		ILLfactor_ftranu3 (f, &f->xtmp, x);
	}
	else
	{
		ILLfactor_ftranu (f, work_coef, x);
	}

#ifdef SORT_RESULTS
	sort_vector (x);
#endif

#ifdef DEBUG_FACTOR
	{
		QSlog("dbl_ILLfactor_ftran x:");
		for (i = 0; i < x->nzcnt; i++)
		{
			QSlog(" %d %la", x->indx[i], dbl_EGlpNumToLf (x->coef[i]));
		}
	}
#endif /* DEBUG_FACTOR */
	return;
}

int dbl_compute_spike (
    dbl_factor_work * f,
    dbl_svector * a,
    dbl_svector * spike)
{
    int i;
    int nzcnt;
    int sparse;
    int *aindx;
    double *acoef;
    double *work_coef = f->work_coef;

    // Determine if we should use sparse or dense methods
    if (a->nzcnt >= SPARSE_FACTOR * f->dim)
    {
        // Dense case: copy input to work array
        aindx = a->indx;
        acoef = a->coef;
        nzcnt = a->nzcnt;
        for (i = 0; i < nzcnt; i++)
        {
            dbl_EGlpNumCopy(work_coef[aindx[i]], acoef[i]);
        }
        sparse = 0;
    }
    else
    {
        sparse = 1;
    }

    // Apply L^{-1}
    if (sparse)
    {
        ILLfactor_ftranl3(f, a, spike);  // Note: spike, not &spike
        // Check if result became dense
        if (spike->nzcnt >= SPARSE_FACTOR * f->dim)
        {
            nzcnt = spike->nzcnt;
            aindx = spike->indx;
            acoef = spike->coef;
            for (i = 0; i < nzcnt; i++)
            {
                dbl_EGlpNumCopy(work_coef[aindx[i]], acoef[i]);
            }
            sparse = 0;
        }
    }
    else
    {
        ILLfactor_ftranl(f, work_coef);
    }

    // Apply E^{-1} (eta factors)
    if (sparse)
    {
        ILLfactor_ftrane2(f, spike);
    }
    else
    {
        ILLfactor_ftrane(f, work_coef);
        // Convert dense result back to sparse
        nzcnt = 0;
        aindx = spike->indx;
        acoef = spike->coef;
        for (i = 0; i < f->dim; i++)
        {
            if (dbl_EGlpNumIsNeqZero(work_coef[i], f->szero_tol))
            {
                aindx[nzcnt] = i;
                dbl_EGlpNumCopy(acoef[nzcnt], work_coef[i]);
                nzcnt++;
            }
            dbl_EGlpNumZero(work_coef[i]); // Clean up
        }
        spike->nzcnt = nzcnt;
    }
	return 0;
}

/* dbl_ILLfactor_ftran_update solves Bx=a for x, and also returns upd, where Ux=upd */
void dbl_ILLfactor_ftran_update (
	dbl_factor_work * f,
	dbl_svector * a,
	dbl_svector * upd,
	dbl_svector * x)
{
	int i;
	int nzcnt;
	int dim;
	int sparse;
	int *aindx;
	double *acoef;
	double *work_coef = f->work_coef;

#ifdef RECORD
	{
		EGioPrintf (fsave, "F %d", a->nzcnt);
		for (i = 0; i < a->nzcnt; i++)
		{
			EGioPrintf (fsave, " %d %.16e", a->indx[i], dbl_EGlpNumToLf (a->coef[i]));
		}
		EGioPrintf (fsave, "\n");
		EGioFlush (fsave);
	}
#endif /* RECORD */
#ifdef DEBUG_FACTOR
	{
		QSlog("dbl_ILLfactor_ftran_update a:");
		for (i = 0; i < a->nzcnt; i++)
		{
			QSlog(" %d %.3f", a->indx[i], dbl_EGlpNumToLf (a->coef[i]));
		}
	}
#endif /* DEBUG_FACTOR */

	if (a->nzcnt >= SPARSE_FACTOR * f->dim)
	{
		aindx = a->indx;
		acoef = a->coef;
		nzcnt = a->nzcnt;

		for (i = 0; i < nzcnt; i++)
		{
			dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
		}
		sparse = 0;
	}
	else
	{
		sparse = 1;
	}

	if (sparse)
	{
		ILLfactor_ftranl3 (f, a, upd);
		if (upd->nzcnt >= SPARSE_FACTOR * f->dim)
		{
			nzcnt = upd->nzcnt;
			aindx = upd->indx;
			acoef = upd->coef;

			for (i = 0; i < nzcnt; i++)
			{
				dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
			}
			sparse = 0;
		}
	}
	else
	{
		ILLfactor_ftranl (f, work_coef);
	}

	if (sparse)
	{
		ILLfactor_ftrane2 (f, upd);
		if (upd->nzcnt >= SPARSE_FACTOR * f->dim)
		{
			nzcnt = upd->nzcnt;
			aindx = upd->indx;
			acoef = upd->coef;

			for (i = 0; i < nzcnt; i++)
			{
				dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
			}
			sparse = 0;
		}
	}
	else
	{
		ILLfactor_ftrane (f, work_coef);
		nzcnt = 0;
		dim = f->dim;
		aindx = upd->indx;
		acoef = upd->coef;
		for (i = 0; i < dim; i++)
		{
			if (dbl_EGlpNumIsNeqqZero (work_coef[i]))
			{
				if (dbl_EGlpNumIsNeqZero (work_coef[i], f->szero_tol))
					/*if(work_coef[i] > szero_tol || work_coef[i] < -szero_tol) */
				{
					aindx[nzcnt] = i;
					dbl_EGlpNumCopy (acoef[nzcnt], work_coef[i]);
					nzcnt++;
				}
			}
		}
		upd->nzcnt = nzcnt;
	}

	if (sparse)
	{
		ILLfactor_ftranu3 (f, upd, x);
	}
	else
	{
		ILLfactor_ftranu (f, work_coef, x);
	}

#ifdef SORT_RESULTS
	sort_vector (upd);
	sort_vector (x);
#endif

#ifdef DEBUG_FACTOR
	{
		QSlog("dbl_ILLfactor_ftran update x:");
		for (i = 0; i < x->nzcnt; i++)
		{
			QSlog(" %d %.3f", x->indx[i], dbl_EGlpNumToLf (x->coef[i]));
		}
	}
#endif /* DEBUG_FACTOR */
}


static void ILLfactor_btranl2 (
	dbl_factor_work * f,
	double * x)
{
	int *lrindx = f->lrindx;
	double *lrcoef = f->lrcoef;
	dbl_lr_info *lr_inf = f->lr_inf;
	int dim = f->dim;
	int nzcnt;
	int beg;
	int i;
	int j;
	double v;

	dbl_EGlpNumInitVar (v);

	for (i = dim - 1; i >= 0; i--)
	{
#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 > 1)
		QSlog("dbl_ILLfactor_btran x before l2 %d:", i);
		for (j = 0; j < f->dim; j++)
		{
			QSlog(" %.3f", dbl_EGlpNumToLf (x[j]));
		}
#endif
#endif /* SOLVE_DEBUG */
		dbl_EGlpNumCopy (v, x[lr_inf[i].r]);
		if (dbl_EGlpNumIsNeqqZero (v))
		{
			nzcnt = lr_inf[i].nzcnt;
			beg = lr_inf[i].rbeg;
			for (j = 0; j < nzcnt; j++)
			{
				dbl_EGlpNumSubInnProdTo (x[lrindx[beg + j]], v, lrcoef[beg + j]);
			}
		}
	}
#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 <= 1)
	QSlog("dbl_ILLfactor_btran x after l2:");
	for (j = 0; j < f->dim; j++)
	{
		QSlog(" %.3f", dbl_EGlpNumToLf (x[j]));
	}
#endif
#endif /* SOLVE_DEBUG */
	dbl_EGlpNumClearVar (v);
}

#if 0
static void btranl3_delay (
	dbl_factor_work * f,
	int r)
{
	dbl_lr_info *lr_inf = f->lr_inf;
	int nzcnt;
	int *indx;
	int i;

	r = lr_inf[r].rrank;
	nzcnt = lr_inf[r].nzcnt;
	indx = f->lrindx + lr_inf[r].rbeg;
	for (i = 0; i < nzcnt; i++)
	{
		r = indx[i];
		if (lr_inf[r].delay++ == 0)
		{
			btranl3_delay (f, r);
		}
	}
}
#endif

static void btranl3_delay2 (
	dbl_factor_work * f,
	int r)
{
	dbl_lr_info *lr_inf = f->lr_inf;
	int nzcnt;
	int *indx;
	int i;
	int last;

	do
	{
		r = lr_inf[r].rrank;
		nzcnt = lr_inf[r].nzcnt;
		indx = f->lrindx + lr_inf[r].rbeg;
		last = -1;
		for (i = 0; i < nzcnt; i++)
		{
			r = indx[i];
			if (lr_inf[r].delay++ == 0)
			{
				if (last >= 0)
				{
					btranl3_delay2 (f, last);
				}
				last = r;
			}
		}
		r = last;
	} while (r >= 0);
}

#if 0
static void btranl3_process (
	dbl_factor_work * f,
	int r,
	dbl_svector * x)
{
	dbl_lr_info *lr_inf = f->lr_inf;
	double *work = f->work_coef;
	int nzcnt;
	int *indx;
	double *coef;
	int i;
	double v;

	dbl_EGlpNumInitVar (v);

	dbl_EGlpNumCopy (v, work[r]);
	dbl_EGlpNumZero (work[r]);
	if (dbl_EGlpNumIsNeqZero (v, f->szero_tol))
		/*if (v > szero_tol || v < -szero_tol) */
	{
		x->indx[x->nzcnt] = r;
		dbl_EGlpNumCopy (x->coef[x->nzcnt], v);
		x->nzcnt++;
	}
	r = lr_inf[r].rrank;
	nzcnt = lr_inf[r].nzcnt;
	indx = f->lrindx + lr_inf[r].rbeg;
	coef = f->lrcoef + lr_inf[r].rbeg;
	for (i = 0; i < nzcnt; i++)
	{
		r = indx[i];
		dbl_EGlpNumSubInnProdTo (work[r], v, coef[i]);
		if (--lr_inf[r].delay == 0)
		{
			btranl3_process (f, r, x);
		}
	}
	dbl_EGlpNumClearVar (v);
}
#endif

static void btranl3_process2 (
	dbl_factor_work * f,
	int r,
	dbl_svector * x)
{
	dbl_lr_info *lr_inf = f->lr_inf;
	double *work = f->work_coef;
	int nzcnt;
	int *indx;
	double *coef;
	int i;
	int last;
	double v;

	dbl_EGlpNumInitVar (v);

	do
	{
		dbl_EGlpNumCopy (v, work[r]);
		dbl_EGlpNumZero (work[r]);
		if (dbl_EGlpNumIsNeqZero (v, f->szero_tol))
			/*if (v > szero_tol || v < -szero_tol) */
		{
			x->indx[x->nzcnt] = r;
			dbl_EGlpNumCopy (x->coef[x->nzcnt], v);
			x->nzcnt++;
		}
		r = lr_inf[r].rrank;
		nzcnt = lr_inf[r].nzcnt;
		indx = f->lrindx + lr_inf[r].rbeg;
		coef = f->lrcoef + lr_inf[r].rbeg;
		last = -1;
		for (i = 0; i < nzcnt; i++)
		{
			r = indx[i];
			dbl_EGlpNumSubInnProdTo (work[r], v, coef[i]);
			if (--lr_inf[r].delay == 0)
			{
				if (last >= 0)
				{
					btranl3_process2 (f, last, x);
				}
				last = r;
			}
		}
		r = last;
	} while (r >= 0);
	dbl_EGlpNumClearVar (v);
}

static void ILLfactor_btranl3 (
	dbl_factor_work * f,
	dbl_svector * a,
	dbl_svector * x)
{
	double *work = f->work_coef;
	int anzcnt = a->nzcnt;
	int *aindx = a->indx;
	double *acoef = a->coef;
	dbl_lr_info *lr_inf = f->lr_inf;
	int i;

	for (i = 0; i < anzcnt; i++)
	{
		if (lr_inf[aindx[i]].delay++ == 0)
		{
			btranl3_delay2 (f, aindx[i]);
		}
		dbl_EGlpNumCopy (work[aindx[i]], acoef[i]);
	}
	x->nzcnt = 0;
	for (i = 0; i < anzcnt; i++)
	{
		if (--lr_inf[aindx[i]].delay == 0)
		{
			btranl3_process2 (f, aindx[i], x);
		}
	}
#ifdef SOLVE_DEBUG
	QSlog("dbl_ILLfactor_btran x after l3:");
	for (i = 0; i < x->nzcnt; i++)
	{
		QSlog(" %.3f*%d", dbl_EGlpNumToLf (x->coef[i]), x->indx[i]);
	}
#endif /* SOLVE_DEBUG */
}

static void ILLfactor_btrane (
	dbl_factor_work * f,
	double * x)
{
	int *erindx = f->erindx;
	double *ercoef = f->ercoef;
	dbl_er_info *er_inf = f->er_inf;
	int etacnt = f->etacnt;
	int beg;
	int nzcnt;
	int i;
	int j;
	double v;

	dbl_EGlpNumInitVar (v);

	for (i = etacnt - 1; i >= 0; i--)
	{
#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 > 1)
		QSlog("dbl_ILLfactor_btran x before eta %d:", i);
		for (j = 0; j < f->dim; j++)
		{
			QSlog(" %.3f", dbl_EGlpNumToLf (x[j]));
		}
#endif
#endif /* SOLVE_DEBUG */
		dbl_EGlpNumCopy (v, x[er_inf[i].r]);
		if (dbl_EGlpNumIsNeqqZero (v))
		{
			nzcnt = er_inf[i].nzcnt;
			beg = er_inf[i].rbeg;
			for (j = 0; j < nzcnt; j++)
			{
				dbl_EGlpNumSubInnProdTo (x[erindx[beg + j]], v, ercoef[beg + j]);
			}
		}
	}
#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 <= 1)
	QSlog("dbl_ILLfactor_btran x after eta:");
	for (j = 0; j < f->dim; j++)
	{
		QSlog(" %.3f", dbl_EGlpNumToLf (x[j]));
	}
#endif
#endif /* SOLVE_DEBUG */
	dbl_EGlpNumClearVar (v);
}

static void ILLfactor_btrane2 (
	dbl_factor_work * f,
	dbl_svector * x)
{
	int *erindx = f->erindx;
	double *ercoef = f->ercoef;
	dbl_er_info *er_inf = f->er_inf;
	int etacnt = f->etacnt;
	int beg;
	int nzcnt;
	int xnzcnt = x->nzcnt;
	int *xindx = x->indx;
	double *xcoef = x->coef;
	double *work_coef = f->work_coef;
	int *work_indx = f->work_indx;
	int i;
	int j;
	double v;

	dbl_EGlpNumInitVar (v);

	for (i = 0; i < xnzcnt; i++)
	{
		dbl_EGlpNumCopy (work_coef[xindx[i]], xcoef[i]);
		work_indx[xindx[i]] = i + 1;
	}
	for (i = etacnt - 1; i >= 0; i--)
	{
#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 > 1)
		QSlog("dbl_ILLfactor_btran x before eta2 %d:", i);
		for (j = 0; j < xnzcnt; j++)
		{
			QSlog(" %.3f*%d", dbl_EGlpNumToLf (work_coef[xindx[j]]), xindx[j]);
		}
#endif
#endif /* SOLVE_DEBUG */
		dbl_EGlpNumCopy (v, work_coef[er_inf[i].r]);
		if (dbl_EGlpNumIsNeqqZero (v))
		{
			nzcnt = er_inf[i].nzcnt;
			beg = er_inf[i].rbeg;
			for (j = 0; j < nzcnt; j++)
			{
				if (work_indx[erindx[beg + j]] == 0)
				{
					work_indx[erindx[beg + j]] = xnzcnt;
					xindx[xnzcnt++] = erindx[beg + j];
				}
				dbl_EGlpNumSubInnProdTo (work_coef[erindx[beg + j]], v, ercoef[beg + j]);
			}
		}
	}

	j = 0;
	while (j < xnzcnt)
	{
		dbl_EGlpNumCopy (xcoef[j], work_coef[xindx[j]]);
		dbl_EGlpNumZero (work_coef[xindx[j]]);
		work_indx[xindx[j]] = 0;
		if (!dbl_EGlpNumIsNeqqZero (xcoef[j]))
		{
			--xnzcnt;
			xindx[j] = xindx[xnzcnt];
		}
		else
		{
			j++;
		}
	}
	x->nzcnt = xnzcnt;

#ifdef SOLVE_DEBUG
#if (SOLVE_DEBUG+0 <= 1)
	QSlog("dbl_ILLfactor_btran x after eta2:");
	for (j = 0; j < xnzcnt; j++)
	{
		QSlog(" %.3f*%d", dbl_EGlpNumToLf (xcoef[j]), xindx[j]);
	}
#endif
#endif /* SOLVE_DEBUG */
	dbl_EGlpNumClearVar (v);
}

static void ILLfactor_btranu (
	dbl_factor_work * f,
	double * a,
	dbl_svector * x)
{
	int *urindx = f->urindx;
	double *urcoef = f->urcoef;
	dbl_ur_info *ur_inf = f->ur_inf;
	int *rperm = f->rperm;
	int *cperm = f->cperm;
	int dim = f->dim;
	int xnzcnt = 0;
	int *xindx = x->indx;
	double *xcoef = x->coef;
	int nzcnt;
	int beg;
	int i;
	int j;
	double v;

	dbl_EGlpNumInitVar (v);

	for (i = 0; i < dim; i++)
	{
		dbl_EGlpNumCopy (v, a[cperm[i]]);
		if (dbl_EGlpNumIsNeqqZero (v))
		{
			j = rperm[i];
			beg = ur_inf[j].rbeg;
			dbl_EGlpNumDivTo (v, urcoef[beg]);
			if (dbl_EGlpNumIsNeqZero (v, f->szero_tol))	/*
																							 * if (v > szero_tol || v < -szero_tol) */
			{
				xindx[xnzcnt] = j;
				dbl_EGlpNumCopy (xcoef[xnzcnt], v);
				xnzcnt++;
			}
			nzcnt = ur_inf[j].nzcnt;
			for (j = 1; j < nzcnt; j++)
			{
				dbl_EGlpNumSubInnProdTo (a[urindx[beg + j]], v, urcoef[beg + j]);
			}
			dbl_EGlpNumZero (a[cperm[i]]);
		}
	}
	x->nzcnt = xnzcnt;
#ifdef SOLVE_DEBUG
	QSlog("dbl_ILLfactor_btran x after u:");
	for (i = 0; i < x->nzcnt; i++)
	{
		QSlog(" %.3f*%d", dbl_EGlpNumToLf (x->coef[i]), x->indx[i]);
	}
#endif /* SOLVE_DEBUG */
	dbl_EGlpNumClearVar (v);
}


#if 0
static void btranu3_delay (
	dbl_factor_work * f,
	int r)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	int nzcnt;
	int *indx;
	int i;

	r = f->rperm[f->crank[r]];
	nzcnt = ur_inf[r].nzcnt;
	indx = f->urindx + ur_inf[r].rbeg;
	for (i = 1; i < nzcnt; i++)
	{
		r = indx[i];
		if (ur_inf[r].delay++ == 0)
		{
			btranu3_delay (f, r);
		}
	}
}
#endif

static void btranu3_delay2 (
	dbl_factor_work * f,
	int r)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	int nzcnt;
	int *indx;
	int i;
	int last;

	do
	{
		r = f->rperm[f->crank[r]];
		nzcnt = ur_inf[r].nzcnt;
		indx = f->urindx + ur_inf[r].rbeg;
		last = -1;
		for (i = 1; i < nzcnt; i++)
		{
			r = indx[i];
			if (ur_inf[r].delay++ == 0)
			{
				if (last >= 0)
				{
					btranu3_delay2 (f, last);
				}
				last = r;
			}
		}
		r = last;
	} while (r >= 0);
}

#if 0
static void btranu3_process (
	dbl_factor_work * f,
	int r,
	dbl_svector * x)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	double *work = f->work_coef;
	int nzcnt;
	int *indx;
	double *coef;
	int i;
	double v;

	dbl_EGlpNumInitVar (v);

	dbl_EGlpNumCopy (v, work[r]);
	dbl_EGlpNumZero (work[r]);
	r = f->rperm[f->crank[r]];
	nzcnt = ur_inf[r].nzcnt;
	indx = f->urindx + ur_inf[r].rbeg;
	coef = f->urcoef + ur_inf[r].rbeg;
	dbl_EGlpNumDivTo (v, coef[0]);
	if (dbl_EGlpNumIsNeqqZero (v))
	{
		x->indx[x->nzcnt] = r;
		dbl_EGlpNumCopy (x->coef[x->nzcnt], v);
		x->nzcnt++;
	}
	for (i = 1; i < nzcnt; i++)
	{
		r = indx[i];
		dbl_EGlpNumSubInnProdTo (work[r], v, coef[i]);
		if (--ur_inf[r].delay == 0)
		{
			btranu3_process (f, r, x);
		}
	}
	dbl_EGlpNumClearVar (v);
}
#endif

static void btranu3_process2 (
	dbl_factor_work * f,
	int r,
	dbl_svector * x)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	double *work = f->work_coef;
	int nzcnt;
	int *indx;
	double *coef;
	int i;
	int last;
	double v;

	dbl_EGlpNumInitVar (v);

	do
	{
		dbl_EGlpNumCopy (v, work[r]);
		dbl_EGlpNumZero (work[r]);
		r = f->rperm[f->crank[r]];
		nzcnt = ur_inf[r].nzcnt;
		indx = f->urindx + ur_inf[r].rbeg;
		coef = f->urcoef + ur_inf[r].rbeg;
		dbl_EGlpNumDivTo (v, coef[0]);
		if (dbl_EGlpNumIsNeqqZero (v))
		{
			x->indx[x->nzcnt] = r;
			dbl_EGlpNumCopy (x->coef[x->nzcnt], v);
			x->nzcnt++;
		}
		last = -1;
		for (i = 1; i < nzcnt; i++)
		{
			r = indx[i];
			dbl_EGlpNumSubInnProdTo (work[r], v, coef[i]);
			if (--ur_inf[r].delay == 0)
			{
				if (last >= 0)
				{
					btranu3_process2 (f, last, x);
				}
				last = r;
			}
		}
		r = last;
	} while (r >= 0);
	dbl_EGlpNumClearVar (v);
}

static void ILLfactor_btranu3 (
	dbl_factor_work * f,
	dbl_svector * a,
	dbl_svector * x)
{
	double *work = f->work_coef;
	int anzcnt = a->nzcnt;
	int *aindx = a->indx;
	double *acoef = a->coef;
	dbl_ur_info *ur_inf = f->ur_inf;
	int i;

	for (i = 0; i < anzcnt; i++)
	{
		if (ur_inf[aindx[i]].delay++ == 0)
		{
			btranu3_delay2 (f, aindx[i]);
		}
		dbl_EGlpNumCopy (work[aindx[i]], acoef[i]);
	}
	x->nzcnt = 0;
	for (i = 0; i < anzcnt; i++)
	{
		if (--ur_inf[aindx[i]].delay == 0)
		{
			btranu3_process2 (f, aindx[i], x);
		}
	}
#ifdef SOLVE_DEBUG
	QSlog("dbl_ILLfactor_btran x after u3:");
	for (i = 0; i < x->nzcnt; i++)
	{
		QSlog(" %.3f*%d", dbl_EGlpNumToLf (x->coef[i]), x->indx[i]);
	}
#endif /* SOLVE_DEBUG */
}

/* dbl_ILLfactor_btran solves x^tB=a^t (or, B^t x = a) for x */
void dbl_ILLfactor_btran (
	dbl_factor_work * f,
	dbl_svector * a,
	dbl_svector * x)
{
	int i;
	int nzcnt;
	int sparse;
	int *aindx = a->indx;
	double *acoef = a->coef;
	double *work_coef = f->work_coef;
	int dim = f->dim;

#ifdef RECORD
	{
		EGioPrintf (fsave, "b %d", a->nzcnt);
		for (i = 0; i < a->nzcnt; i++)
		{
			EGioPrintf (fsave, " %d %.16e", a->indx[i], dbl_EGlpNumToLf (a->coef[i]));
		}
		EGioPrintf (fsave, "\n");
		EGioFlush (fsave);
	}
#endif /* RECORD */
#ifdef DEBUG_FACTOR
	{
		QSlog("dbl_ILLfactor_btran a:");
		for (i = 0; i < a->nzcnt; i++)
		{
			QSlog(" %d %.3f", a->indx[i], dbl_EGlpNumToLf (a->coef[i]));
		}
	}
#endif /* DEBUG_FACTOR */

	if (a->nzcnt >= SPARSE_FACTOR * f->dim)
	{
		aindx = a->indx;
		acoef = a->coef;
		work_coef = f->work_coef;
		nzcnt = a->nzcnt;
		for (i = 0; i < nzcnt; i++)
		{
			dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
		}
		sparse = 0;
	}
	else
	{
		sparse = 1;
	}

	if (sparse)
	{
		ILLfactor_btranu3 (f, a, &f->xtmp);
	}
	else
	{
		ILLfactor_btranu (f, work_coef, &f->xtmp);
	}

	if (f->xtmp.nzcnt >= SPARSE_FACTOR * f->dim)
	{
		aindx = f->xtmp.indx;
		acoef = f->xtmp.coef;
		work_coef = f->work_coef;
		nzcnt = f->xtmp.nzcnt;
		for (i = 0; i < nzcnt; i++)
		{
			dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
		}
		sparse = 0;
	}
	else
	{
		sparse = 1;
	}

	if (sparse)
	{
		ILLfactor_btrane2 (f, &f->xtmp);
		if (f->xtmp.nzcnt >= SPARSE_FACTOR * f->dim)
		{
			aindx = f->xtmp.indx;
			acoef = f->xtmp.coef;
			work_coef = f->work_coef;
			nzcnt = f->xtmp.nzcnt;
			for (i = 0; i < nzcnt; i++)
			{
				dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
			}
			sparse = 0;
		}
	}
	else
	{
		ILLfactor_btrane (f, work_coef);
	}

	if (sparse)
	{
		ILLfactor_btranl3 (f, &f->xtmp, x);
	}
	else
	{
		ILLfactor_btranl2 (f, work_coef);
		dim = f->dim;
		nzcnt = 0;
		aindx = x->indx;
		acoef = x->coef;
		for (i = 0; i < dim; i++)
		{
			if (dbl_EGlpNumIsNeqqZero (work_coef[i]))
			{
				if (dbl_EGlpNumIsNeqZero (work_coef[i], f->szero_tol))
					/*if (work_coef[i] > szero_tol || work_coef[i] < -szero_tol) */
				{
					aindx[nzcnt] = i;
					dbl_EGlpNumCopy (acoef[nzcnt], work_coef[i]);
					nzcnt++;
				}
				dbl_EGlpNumZero (work_coef[i]);
			}
		}
		x->nzcnt = nzcnt;
	}

#ifdef SORT_RESULTS
	sort_vector (x);
#endif

#ifdef DEBUG_FACTOR
	{
		QSlog("dbl_ILLfactor_btran x:");
		for (i = 0; i < x->nzcnt; i++)
		{
			QSlog(" %d %.3f", x->indx[i], dbl_EGlpNumToLf (x->coef[i]));
		}
	}
#endif /* DEBUG_FACTOR */
	return;
}

static int expand_col (
	dbl_factor_work * f,
	int col)
{
	dbl_uc_info *uc_inf = f->uc_inf + col;
	int uc_freebeg = f->uc_freebeg;
	int nzcnt = uc_inf->nzcnt;
	int cbeg;
	double *uccoef;
	int *ucindx;
	int *ucrind;
	int i;
	int rval = 0;

	if (uc_freebeg + nzcnt + 1 >= f->uc_space)
	{
		rval = make_uc_space (f, nzcnt + 1);
		CHECKRVALG (rval, CLEANUP);
		uc_freebeg = f->uc_freebeg;
	}
	cbeg = uc_inf->cbeg;
	uccoef = f->uccoef;
	ucindx = f->ucindx;
	ucrind = f->ucrind;

	for (i = 0; i < nzcnt; i++)
	{
		dbl_EGlpNumCopy (uccoef[uc_freebeg + i], uccoef[cbeg + i]);
		ucindx[uc_freebeg + i] = ucindx[cbeg + i];
		ucrind[uc_freebeg + i] = ucrind[cbeg + i];
		ucindx[cbeg + i] = -1;
	}

	uc_inf->cbeg = uc_freebeg;
	f->uc_freebeg = uc_freebeg + nzcnt;
CLEANUP:
	EG_RETURN (rval);
}

static int expand_row (
	dbl_factor_work * f,
	int row)
{
	dbl_ur_info *ur_inf = f->ur_inf + row;
	int ur_freebeg = f->ur_freebeg;
	int nzcnt = ur_inf->nzcnt;
	int rbeg;
	double *urcoef;
	int *urindx;
	int *urcind;
	int i;
	int rval = 0;

	if (ur_freebeg + nzcnt + 1 >= f->ur_space)
	{
		rval = make_ur_space (f, nzcnt + 1);
		CHECKRVALG (rval, CLEANUP);
		ur_freebeg = f->ur_freebeg;
	}
	rbeg = ur_inf->rbeg;
	urcoef = f->urcoef;
	urindx = f->urindx;
	urcind = f->urcind;

	for (i = 0; i < nzcnt; i++)
	{
		dbl_EGlpNumCopy (urcoef[ur_freebeg + i], urcoef[rbeg + i]);
		urindx[ur_freebeg + i] = urindx[rbeg + i];
		urcind[ur_freebeg + i] = urcind[rbeg + i];
		urindx[rbeg + i] = -1;
	}

	ur_inf->rbeg = ur_freebeg;
	f->ur_freebeg = ur_freebeg + nzcnt;
CLEANUP:
	EG_RETURN (rval);
}

static int add_nonzero (
	dbl_factor_work * f,
	int row,
	int col,
	double val)
{
	dbl_ur_info *ur_inf = f->ur_inf + row;
	dbl_uc_info *uc_inf = f->uc_inf + col;
	int cnzcnt = uc_inf->nzcnt;
	int rnzcnt = ur_inf->nzcnt;
	int cloc = uc_inf->cbeg + cnzcnt;
	int rloc = ur_inf->rbeg + rnzcnt;
	int rval = 0;

	if (f->ucindx[cloc] != -1)
	{
		rval = expand_col (f, col);
		CHECKRVALG (rval, CLEANUP);
		cloc = uc_inf->cbeg + cnzcnt;
	}
	TESTG ((rval = (rloc < 0 || rloc > f->ur_space)), CLEANUP,
				 "rloc %d outside boundaries [0:%d]", rloc, f->ur_space);
	if (f->urindx[rloc] != -1)
	{
		rval = expand_row (f, row);
		CHECKRVALG (rval, CLEANUP);
		rloc = ur_inf->rbeg + rnzcnt;
	}
	f->ucindx[cloc] = row;
	dbl_EGlpNumCopy (f->uccoef[cloc], val);
	f->ucrind[cloc] = rnzcnt;
	f->urindx[rloc] = col;
	dbl_EGlpNumCopy (f->urcoef[rloc], val);
	f->urcind[rloc] = cnzcnt;

	if (cloc == f->uc_freebeg)
		f->uc_freebeg++;
	if (rloc == f->ur_freebeg)
		f->ur_freebeg++;

	uc_inf->nzcnt = cnzcnt + 1;
	ur_inf->nzcnt = rnzcnt + 1;
CLEANUP:
	EG_RETURN (rval);
}

static int delete_nonzero_row (
	dbl_factor_work * f,
	int row,
	int ind)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	double *urcoef = f->urcoef;
	int *urindx = f->urindx;
	int *urcind = f->urcind;
	int *ucrind = f->ucrind;
	int rbeg = ur_inf[row].rbeg;
	int nzcnt = ur_inf[row].nzcnt - 1;
	int cbeg, rval = 0;
	#ifdef DEBUG_FACTOR
	TESTG((rval=(nzcnt<0)),CLEANUP,"Deleting empty row %d ind %d!",row, ind);
	#endif

	if (ind != nzcnt)
	{
		dbl_EGlpNumCopy (urcoef[rbeg + ind], urcoef[rbeg + nzcnt]);
		urindx[rbeg + ind] = urindx[rbeg + nzcnt];
		urcind[rbeg + ind] = urcind[rbeg + nzcnt];
		cbeg = f->uc_inf[urindx[rbeg + nzcnt]].cbeg;
		ucrind[cbeg + urcind[rbeg + nzcnt]] = ind;
		urindx[rbeg + nzcnt] = -1;
	}
	ur_inf[row].nzcnt = nzcnt;
	#ifdef DEBUG_FACTOR
	CLEANUP:
	#endif
	return rval;
}

static void delete_nonzero_col (
	dbl_factor_work * f,
	int col,
	int ind)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	double *uccoef = f->uccoef;
	int *ucindx = f->ucindx;
	int *ucrind = f->ucrind;
	int *urcind = f->urcind;
	int cbeg = uc_inf[col].cbeg;
	int nzcnt = uc_inf[col].nzcnt - 1;
	int rbeg;

	if (ind != nzcnt)
	{
		dbl_EGlpNumCopy (uccoef[cbeg + ind], uccoef[cbeg + nzcnt]);
		ucindx[cbeg + ind] = ucindx[cbeg + nzcnt];
		ucrind[cbeg + ind] = ucrind[cbeg + nzcnt];
		rbeg = f->ur_inf[ucindx[cbeg + nzcnt]].rbeg;
		urcind[rbeg + ucrind[cbeg + nzcnt]] = ind;
		ucindx[cbeg + nzcnt] = -1;
	}
	uc_inf[col].nzcnt = nzcnt;
}

static int delete_column (
	dbl_factor_work * f,
	int col)
{
	dbl_uc_info *uc_inf = f->uc_inf;
	int beg = uc_inf[col].cbeg;
	int nzcnt = uc_inf[col].nzcnt;
	int *ucindx = f->ucindx + beg;
	int *ucrind = f->ucrind + beg;
	int i, rval = 0;
	#ifdef DEBUG_FACTOR
	rval = check_matrix(f);
	TESTG(rval,CLEANUP,"Corrupted Matrix");
	#endif

	for (i = 0; i < nzcnt; i++)
	{
		rval = delete_nonzero_row (f, ucindx[i], ucrind[i]);
		CHECKRVALG(rval,CLEANUP);
		ucindx[i] = -1;
	}
	uc_inf[col].nzcnt = 0;

#ifdef TRACK_FACTOR
	f->nzcnt_cur -= nzcnt;
#endif

	#ifdef DEBUG_FACTOR
	rval = check_matrix(f);
	TESTG(rval,CLEANUP,"Corrupted Matrix");
	#endif /* DEBUG_FACTOR */
	CLEANUP:
	EG_RETURN(rval);
}

static int delete_row (
	dbl_factor_work * f,
	int row,
	dbl_svector * x)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	int beg = ur_inf[row].rbeg;
	int nzcnt = ur_inf[row].nzcnt;
	int *urindx = f->urindx + beg;
	double *urcoef = f->urcoef + beg;
	int *urcind = f->urcind + beg;
	int i,rval=0;

	#ifdef DEBUG_FACTOR
	rval = check_matrix(f);
	TESTG(rval,CLEANUP,"Corrupted Matrix");
	#endif /* DEBUG_FACTOR */

	for (i = 0; i < nzcnt; i++)
	{
		x->indx[i] = urindx[i];
		dbl_EGlpNumCopy (x->coef[i], urcoef[i]);
		delete_nonzero_col (f, urindx[i], urcind[i]);
		urindx[i] = -1;
	}
	x->nzcnt = nzcnt;
	ur_inf[row].nzcnt = 0;

#ifdef TRACK_FACTOR
	f->nzcnt_cur -= nzcnt;
#endif

	#ifdef DEBUG_FACTOR
	rval = check_matrix(f);
	TESTG(rval,CLEANUP,"Corrupted Matrix");
	CLEANUP:
	#endif /* DEBUG_FACTOR */
	return rval;
}

static int create_column (
	dbl_factor_work * f,
	dbl_svector * a,
	int col,
	int *p_last_rank)
{
	int *rrank = f->rrank;
	int nzcnt = a->nzcnt;
	int *aindx = a->indx;
	double *acoef = a->coef;
	int i;
	int j;
	int rval = 0;
	int last_rank = -1;

#ifdef TRACK_FACTOR
	double max;

	dbl_EGlpNumInitVar (max);
	dbl_EGlpNumCopy (max, f->maxelem_cur);
#endif /* TRACK_FACTOR */

	last_rank = 0;

	for (i = 0; i < nzcnt; i++)
	{
		rval = add_nonzero (f, aindx[i], col, acoef[i]);
		CHECKRVALG (rval, CLEANUP);
#ifdef TRACK_FACTOR
		dbl_EGlpNumSetToMaxAbs (max, acoef[i]);
#endif /* TRACK_FACTOR */
		j = rrank[aindx[i]];
		if (j > last_rank)
			last_rank = j;
	}
	*p_last_rank = last_rank;

#ifdef TRACK_FACTOR
	f->nzcnt_cur += nzcnt;
	dbl_EGlpNumCopy (f->maxelem_cur, max);
	dbl_EGlpNumClearVar (max);
#endif /* TRACK_FACTOR */

	#ifdef DEBUG_FACTOR
	rval = check_matrix(f);
	TESTG(rval,CLEANUP,"Corrupted Matrix");
	#endif /* DEBUG_FACTOR */

	CLEANUP:
	EG_RETURN (rval);
}

#ifdef UPDATE_STUDY
static int column_rank (
	dbl_factor_work * f,
	int col)
{
	int *cperm = f->cperm;
	int dim = f->dim;
	int i;

	for (i = 0; i < dim; i++)
	{
		if (cperm[i] == col)
		{
			return i;
		}
	}
	return 0;
}
#endif

static void shift_permutations (
	dbl_factor_work * f,
	int rank_p,
	int rank_r)
{
	int *cperm = f->cperm;
	int *crank = f->crank;
	int *rperm = f->rperm;
	int *rrank = f->rrank;
	int col_p = cperm[rank_p];
	int row_p = rperm[rank_p];
	int i;

	for (i = rank_p; i < rank_r; i++)
	{
		cperm[i] = cperm[i + 1];
		crank[cperm[i]] = i;
		rperm[i] = rperm[i + 1];
		rrank[rperm[i]] = i;
	}
	cperm[rank_r] = col_p;
	crank[col_p] = rank_r;
	rperm[rank_r] = row_p;
	rrank[row_p] = rank_r;
}

static int eliminate_row (
	dbl_factor_work * f,
	int rank_p,
	int rank_r)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	int *rperm = f->rperm;
	int *cperm = f->cperm;
	int *urindx = f->urindx;
	double *urcoef = f->urcoef;
	int *erindx = f->erindx;
	double *ercoef = f->ercoef;
	double *work_coef = f->work_coef;
	int er_freebeg = f->er_freebeg;
	int er_space = f->er_space;
	int beg;
	int nzcnt;
	int i;
	int j;
	int c;
	int r;
	double pivot_mul;

#ifdef TRACK_FACTOR
	double max;

	dbl_EGlpNumInitVar (max);
	dbl_EGlpNumCopy (max, f->maxelem_cur);
#endif /* TRACK_FACTOR */
	dbl_EGlpNumInitVar (pivot_mul);

	for (i = rank_p; i < rank_r; i++)
	{
		c = cperm[i];
		if (dbl_EGlpNumIsNeqZero (work_coef[c], f->fzero_tol))	/*
																												 * if (work_coef[c] > fzero_tol || work_coef[c] < -fzero_tol) */
		{
			r = rperm[i];
			beg = ur_inf[r].rbeg;
			nzcnt = ur_inf[r].nzcnt;
			dbl_EGlpNumCopyFrac (pivot_mul, work_coef[c], urcoef[beg]);
			dbl_EGlpNumZero (work_coef[c]);
			for (j = 1; j < nzcnt; j++)
			{
				dbl_EGlpNumSubInnProdTo (work_coef[urindx[beg + j]], pivot_mul, urcoef[beg + j]);	/* 0.85 */
			}
			if (er_freebeg >= er_space)
			{
				/* QSlog("no space in eliminate_row"); */
#ifdef TRACK_FACTOR
				dbl_EGlpNumClearVar (max);
#endif
				dbl_EGlpNumClearVar (pivot_mul);
				return E_UPDATE_NOSPACE;
			}
			erindx[er_freebeg] = r;
			dbl_EGlpNumCopy (ercoef[er_freebeg], pivot_mul);
#ifdef TRACK_FACTOR
			dbl_EGlpNumSetToMaxAbs (max, pivot_mul);
#endif /* TRACK_FACTOR */
			er_freebeg++;
		}
		else
		{
			dbl_EGlpNumZero (work_coef[c]);
		}
	}
	f->er_freebeg = er_freebeg;
#ifdef TRACK_FACTOR
	dbl_EGlpNumCopy (f->maxelem_cur, max);
	dbl_EGlpNumClearVar (max);
#endif /* TRACK_FACTOR */
	dbl_EGlpNumClearVar (pivot_mul);
	return 0;
}

static int create_row (
	dbl_factor_work * f,
	double * a,
	int row,
	int minrank)
{
	int *cperm = f->cperm;
	int dim = f->dim;
	int i;
	int j;
	int rval = 0;

#ifdef TRACK_FACTOR
	double max;

	dbl_EGlpNumInitVar (max);
	dbl_EGlpNumCopy (max, f->maxelem_cur);
#endif /* TRACK_FACTOR */

	for (i = minrank; i < dim; i++)
	{
		if (dbl_EGlpNumIsNeqqZero (a[cperm[i]]))
		{
			j = cperm[i];
			if (dbl_EGlpNumIsNeqZero (a[j], f->fzero_tol))	/*
																									 * if (a[j] > fzero_tol || a[j] < -fzero_tol) */
			{
				rval = add_nonzero (f, row, j, a[j]);
				CHECKRVALG (rval, CLEANUP);
#ifdef TRACK_FACTOR
				dbl_EGlpNumSetToMaxAbs (max, a[j]);
#endif /* TRACK_FACTOR */
			}
			dbl_EGlpNumZero (a[j]);
		}
	}

#ifdef TRACK_FACTOR
	f->nzcnt_cur += f->ur_inf[row].nzcnt;
	dbl_EGlpNumCopy (f->maxelem_cur, max);
	dbl_EGlpNumClearVar (max);
#endif /* TRACK_FACTOR */

	#ifdef DEBUG_FACTOR
	rval = check_matrix(f);
	TESTG(rval,CLEANUP,"Corrupted Matrix");
	#endif /* DEBUG_FACTOR */
	CLEANUP:
	EG_RETURN (rval);
}

static void serow_delay (
	dbl_factor_work * f,
	int r,
	int rank_r)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	int *crank = f->crank;
	int nzcnt;
	int *indx;
	int i;
	int last;

	do
	{
		r = f->rperm[crank[r]];
		nzcnt = ur_inf[r].nzcnt;
		indx = f->urindx + ur_inf[r].rbeg;
		last = -1;
		for (i = 1; i < nzcnt; i++)
		{
			r = indx[i];
			if (ur_inf[r].delay++ == 0 && crank[r] < rank_r)
			{
				if (last >= 0)
				{
					serow_delay (f, last, rank_r);
				}
				last = r;
			}
		}
		r = last;
	} while (r >= 0);
}

static int serow_process (
	dbl_factor_work * f,
	int r,
	dbl_svector * newr,
	int rank_r)
{
	dbl_ur_info *ur_inf = f->ur_inf;
	double *work = f->work_coef;
	int nzcnt;
	int *indx;
	double *coef;
	int i;
	double v;
	int last;
	int rval;

	dbl_EGlpNumInitVar (v);

	do
	{
		dbl_EGlpNumCopy (v, work[r]);
		dbl_EGlpNumZero (work[r]);
		if (f->crank[r] >= rank_r)
		{
			if (dbl_EGlpNumIsNeqZero (v, f->fzero_tol))	/*
																							 * if (v > fzero_tol || v < -fzero_tol) */
			{
				/* stash this nonzero in the resulting row */
#ifdef TRACK_FACTOR
				dbl_EGlpNumSetToMaxAbs (f->maxelem_cur, v);
#endif /* TRACK_FACTOR */
				newr->indx[newr->nzcnt] = r;
				dbl_EGlpNumCopy (newr->coef[newr->nzcnt], v);
				newr->nzcnt++;
				dbl_EGlpNumClearVar (v);
				return 0;
			}
			else
			{
				dbl_EGlpNumClearVar (v);
				return 0;
			}
		}
		r = f->rperm[f->crank[r]];
		nzcnt = ur_inf[r].nzcnt;
		indx = f->urindx + ur_inf[r].rbeg;
		coef = f->urcoef + ur_inf[r].rbeg;
		dbl_EGlpNumDivTo (v, coef[0]);
		if (dbl_EGlpNumIsNeqZero (v, f->fzero_tol))	/*
																						 * if (v > fzero_tol || v < -fzero_tol) */
		{
			/* stash v in eta */
			if (f->er_freebeg >= f->er_space)
			{
				/* QSlog("no space in eliminate_row"); */
				dbl_EGlpNumClearVar (v);
				return E_UPDATE_NOSPACE;
			}
			f->erindx[f->er_freebeg] = r;
			dbl_EGlpNumCopy (f->ercoef[f->er_freebeg], v);
#ifdef TRACK_FACTOR
			dbl_EGlpNumSetToMaxAbs (f->maxelem_cur, v);
#endif /* TRACK_FACTOR */
			f->er_freebeg++;
		}
		last = -1;
		for (i = 1; i < nzcnt; i++)
		{
			r = indx[i];
			dbl_EGlpNumSubInnProdTo (work[r], v, coef[i]);
			if (--ur_inf[r].delay == 0)
			{
				if (last >= 0)
				{
					rval = serow_process (f, last, newr, rank_r);
					if (rval)
					{
						dbl_EGlpNumClearVar (v);
						return rval;
					}
				}
				last = r;
			}
		}
		r = last;
	} while (r >= 0);
	dbl_EGlpNumClearVar (v);
	return 0;
}

static int sparse_eliminate_row (
	dbl_factor_work * f,
	dbl_svector * x,
	int row_p,
	int rank_r)
{
	double *work = f->work_coef;
	int xnzcnt = x->nzcnt;
	int *xindx = x->indx;
	double *xcoef = x->coef;
	dbl_ur_info *ur_inf = f->ur_inf;
	int *crank = f->crank;
	int i;
	int j;
	int rval = 0;
	dbl_svector newr;

	newr.indx = 0;
	newr.coef = 0;

	for (i = 0; i < xnzcnt; i++)
	{
		j = xindx[i];
		if (ur_inf[j].delay++ == 0 && crank[j] < rank_r)
		{
			serow_delay (f, j, rank_r);
		}
		dbl_EGlpNumCopy (work[j], xcoef[i]);
	}

	newr.nzcnt = 0;
	ILL_SAFE_MALLOC (newr.indx, f->dim, int);

	newr.coef = dbl_EGlpNumAllocArray (f->dim);

	for (i = 0; i < xnzcnt; i++)
	{
		j = xindx[i];
		if (--ur_inf[j].delay == 0)
		{
			rval = serow_process (f, j, &newr, rank_r);
			CHECKRVALG (rval, CLEANUP);
		}
	}

	for (i = 0; i < newr.nzcnt; i++)
	{
		rval = add_nonzero (f, row_p, newr.indx[i], newr.coef[i]);
		CHECKRVALG (rval, CLEANUP);
	}

#ifdef TRACK_FACTOR
	f->nzcnt_cur += newr.nzcnt;
#endif /* TRACK_FACTOR */

CLEANUP:
	dbl_EGlpNumFreeArray (newr.coef);
	ILL_IFFREE(newr.indx);

	/* Bico 031210 - chg from ILL_RETURN */
	EG_RETURN (rval);
}

static int move_pivot_row (
	dbl_factor_work * f,
	int r,
	int c)
{
	dbl_ur_info *ur_inf = f->ur_inf + r;
	dbl_uc_info *uc_inf = f->uc_inf;
	int beg = ur_inf->rbeg;
	int nzcnt = ur_inf->nzcnt;
	int *urindx = f->urindx;
	int *urcind = f->urcind;
	int *ucrind = f->ucrind;
	double *urcoef = f->urcoef;
	double dt;
	int it;
	int i;

	if (urindx[beg] == c)
		return 0;
	dbl_EGlpNumInitVar (dt);

	for (i = 1; i < nzcnt; i++)
	{
		if (urindx[beg + i] == c)
		{
			dbl_EGLPNUM_SWAP (urcoef[beg], urcoef[beg + i], dt);
			ILL_SWAP (urcind[beg], urcind[beg + i], it);
			urindx[beg + i] = urindx[beg];
			urindx[beg] = c;
			ucrind[uc_inf[c].cbeg + urcind[beg]] = 0;
			ucrind[uc_inf[urindx[beg + i]].cbeg + urcind[beg + i]] = i;
			dbl_EGlpNumClearVar (dt);
			return 0;
		}
	}
	MESSAGE (__QS_SB_VERB, "pivot row nonzero not found");
	dbl_EGlpNumClearVar (dt);
	return E_UPDATE_SINGULAR_ROW;
}

static int move_pivot_col (
	dbl_factor_work * f,
	int c,
	int r)
{
	dbl_uc_info *uc_inf = f->uc_inf + c;
	dbl_ur_info *ur_inf = f->ur_inf;
	int beg = uc_inf->cbeg;
	int nzcnt = uc_inf->nzcnt;
	int *ucindx = f->ucindx;
	int *ucrind = f->ucrind;
	int *urcind = f->urcind;
	double *uccoef = f->uccoef;
	double dt;
	int i, it;

	if (ucindx[beg] == r)
		return 0;
	dbl_EGlpNumInitVar (dt);

	for (i = 1; i < nzcnt; i++)
	{
		if (ucindx[beg + i] == r)
		{
			dbl_EGLPNUM_SWAP (uccoef[beg], uccoef[beg + i], dt);
			ILL_SWAP (ucrind[beg], ucrind[beg + i], it);
			ucindx[beg + i] = ucindx[beg];
			ucindx[beg] = r;
			urcind[ur_inf[r].rbeg + ucrind[beg]] = 0;
			urcind[ur_inf[ucindx[beg + i]].rbeg + ucrind[beg + i]] = i;
			dbl_EGlpNumClearVar (dt);
			return 0;
		}
	}
	MESSAGE(__QS_SB_VERB, "pivot col nonzero not found");
	dbl_EGlpNumClearVar (dt);
	return E_UPDATE_SINGULAR_COL;
}

static int move_pivot (
	dbl_factor_work * f,
	int rank_r)
{
	int r = f->rperm[rank_r];
	int c = f->cperm[rank_r];
	int rval = 0;

	rval = move_pivot_row (f, r, c);
	CHECKRVALG (rval, CLEANUP);

	#ifdef DEBUG_FACTOR
	rval = check_matrix(f);
	TESTG(rval,CLEANUP,"Corrupted Matrix");
	#endif /* DEBUG_FACTOR */

	rval = move_pivot_col (f, c, r);
	if(rval != E_UPDATE_SINGULAR_COL) CHECKRVALG (rval, CLEANUP);
	else goto CLEANUP;

	#ifdef DEBUG_FACTOR
	rval = check_matrix(f);
	TESTG(rval,CLEANUP,"Corrupted Matrix");
	#endif /* DEBUG_FACTOR */

	CLEANUP:
	if(rval != E_UPDATE_SINGULAR_COL) EG_RETURN (rval);							/* Bico 031209 - chg from RETURN */
	return rval;
}

int dbl_ILLfactor_update (
	dbl_factor_work * f,
	dbl_svector * a,
	int col_p,
	int *p_refact)
{
	int row_p;
	int rank_r = 0;
	int rank_p = 0;
	int rval = 0;
	int nzcnt;
	int *aindx;
	double *acoef;
	double *work_coef = f->work_coef;

#ifdef TRACK_FACTOR
#ifdef NOTICE_BLOWUP
	double tmpsize;
#endif
#endif
	int i;

#ifdef RECORD
	{
		EGioPrintf (fsave, "u %d %d", col_p, a->nzcnt);
		for (i = 0; i < a->nzcnt; i++)
		{
			EGioPrintf (fsave, " %d %.16e", a->indx[i], dbl_EGlpNumToLf (a->coef[i]));
		}
		EGioPrintf (fsave, "\n");
		EGioFlush (fsave);
	}
#endif /* RECORD */

#ifdef DEBUG_FACTOR
	{
		QSlog("dbl_ILLfactor_update col %d:", col_p);
		for (i = 0; i < a->nzcnt; i++)
		{
			QSlog(" %.3f*%d", dbl_EGlpNumToLf (a->coef[i]), a->indx[i]);
		}
	}
#endif /* DEBUG_FACTOR */

	#ifdef DEBUG_FACTOR
	rval = check_matrix(f);
	TESTG(rval,CLEANUP,"Corrupted Matrix");
	#endif /* DEBUG_FACTOR */

	if (f->etacnt >= f->etamax)
	{
		*p_refact = 1;
		return 0;
	}

#ifdef UPDATE_STUDY
	nupdate++;
#endif

	// retrieves the pivot row corresponding to the column being replaced.
	row_p = f->ucindx[f->uc_inf[col_p].cbeg];
	// removes the old column from the factorization.
	rval = delete_column (f, col_p);

	CHECKRVALG (rval, CLEANUP);
	// computes the new column rank (rank_r) for pivot permutation.
	rval = create_column (f, a, col_p, &rank_r);
	/* if (rval) QSlog("create_column failed"); */
	CHECKRVALG (rval, CLEANUP);

	rank_p = f->crank[col_p];
#ifdef UPDATE_STUDY
	if (rank_p != f->rrank[row_p] || rank_p != column_rank (f, col_p))
	{
		QSlog("rank_p %d rrank[row_p] %d column_rank(f,col_p) %d",
								rank_p, f->rrank[row_p], column_rank (f, col_p));
	}
	if (rank_r > rank_p)
	{
		permshifttot += rank_r - rank_p;
	}
	for (i = 0; i < a->nzcnt; i++)
	{
		if (f->rrank[a->indx[i]] > rank_p)
			colspiketot++;
	}
	for (i = 0; i < f->ur_inf[row_p].nzcnt; i++)
	{
		if (f->crank[f->urindx[f->ur_inf[row_p].rbeg + i]] <= rank_r &&
				f->crank[f->urindx[f->ur_inf[row_p].rbeg + i]] != rank_p)
		{
			rowspiketot++;
		}
	}
#endif

	shift_permutations (f, rank_p, rank_r);
	// removes the row and performs sparse or dense elimination to update LU factors.
	rval = delete_row (f, row_p, &f->xtmp);
	CHECKRVALG(rval,CLEANUP);

	f->er_inf[f->etacnt].rbeg = f->er_freebeg;
	f->er_inf[f->etacnt].r = row_p;

	if (f->xtmp.nzcnt >= SPARSE_FACTOR * f->dim)
	{
		nzcnt = f->xtmp.nzcnt;
		aindx = f->xtmp.indx;
		acoef = f->xtmp.coef;

		for (i = 0; i < nzcnt; i++)
		{
			dbl_EGlpNumCopy (work_coef[aindx[i]], acoef[i]);
		}

		rval = eliminate_row (f, rank_p, rank_r);
		/* if (rval) QSlog("eliminate_row failed"); */
		CHECKRVALG (rval, CLEANUP);

		rval = create_row (f, f->work_coef, row_p, rank_r);
		/* if (rval) QSlog("create_row failed"); */
		CHECKRVALG (rval, CLEANUP);
	}
	else
	{
		rval = sparse_eliminate_row (f, &f->xtmp, row_p, rank_r);
		/* if (rval) QSlog("sparse_eliminate_row failed"); */
		CHECKRVALG (rval, CLEANUP);
	}

	if (f->er_freebeg - f->er_inf[f->etacnt].rbeg > 0)
	{
		f->er_inf[f->etacnt].nzcnt = f->er_freebeg - f->er_inf[f->etacnt].rbeg;
#ifdef TRACK_FACTOR
		f->nzcnt_cur += f->er_inf[f->etacnt].nzcnt;
#endif /* TRACK_FACTOR */
#ifdef UPDATE_STUDY
		leftetatot += f->er_inf[f->etacnt].nzcnt;
#endif

#ifdef SORT_RESULTS
		sort_vector2 (f->er_inf[f->etacnt].nzcnt,
									f->erindx + f->er_inf[f->etacnt].rbeg,
									f->ercoef + f->er_inf[f->etacnt].rbeg);
#endif

		f->etacnt++;
	}

	rval = move_pivot (f, rank_r);
	/* if (rval) QSlog("move_pivot failed"); */
	if(rval != E_UPDATE_SINGULAR_COL) CHECKRVALG (rval, CLEANUP);
	else goto CLEANUP;

#ifdef UPDATE_DEBUG
	QSlog("Updated factorization:");
#if (UPDATE_DEBUG+0>1)
	dump_matrix (f, 0);
#endif
#endif /* UPDATE_DEBUG */

#ifdef TRACK_FACTOR
#ifdef NOTICE_BLOWUP
	dbl_EGlpNumInitVar (tmpsize);
	dbl_EGlpNumSet (tmpsize, f->updmaxmult);
	dbl_EGlpNumMultTo (tmpsize, f->maxelem_orig);
	if (dbl_EGlpNumIsLess (tmpsize, f->maxelem_cur))
	{
/* Bico - comment out for dist 
        QSlog("factor_update blowup max cur %e max orig %e",
                    f->maxelem_cur, f->maxelem_orig);
*/
		dbl_EGlpNumClearVar (tmpsize);
		return E_FACTOR_BLOWUP;
	}
	dbl_EGlpNumClearVar (tmpsize);
#endif /* NOTICE_BLOWUP */
#endif
#ifdef UPDATE_STATS
	dump_factor_stats (f);
#endif
CLEANUP:
	if(rval != E_UPDATE_SINGULAR_COL) EG_RETURN (rval);							/* Bico 031209 - chg from RETURN */
	return rval;
}

/**
 * @brief Creates a deep copy of an dbl_factor_work struct.
 *
 * This function allocates new memory for all pointer-based members of the struct
 * and copies the values from the source struct. It uses the memory management
 * conventions of the qsopt-ex library (ILL_SAFE_MALLOC, etc.).
 *
 * @param dest A pointer to the destination struct. This should be an uninitialized struct.
 * @param src A pointer to the source struct to be copied.
 * @return 0 on success, non-zero on memory allocation failure.
 */
 int dbl_ILLfactor_deep_copy(
    dbl_factor_work *dest,
    const dbl_factor_work *src)
{
    int i;
    int rval = 0;
    int dsize;
  
    // Use the project's initialization function to set defaults.
    dbl_ILLfactor_init_factor_work(dest);
    // Copy scalar fields from src to dest.
    dest->max_k = src->max_k;
    dbl_EGlpNumCopy(dest->fzero_tol, src->fzero_tol);
    dbl_EGlpNumCopy(dest->szero_tol, src->szero_tol);
    dbl_EGlpNumCopy(dest->partial_tol, src->partial_tol);
    dest->ur_space_mul = src->ur_space_mul;
    dest->uc_space_mul = src->uc_space_mul;
    dest->lc_space_mul = src->lc_space_mul;
    dest->lr_space_mul = src->lr_space_mul;
    dest->er_space_mul = src->er_space_mul;
    dest->grow_mul = src->grow_mul;
    dest->p = src->p;
    dest->etamax = 500; //TODO: make this dynamic
    dest->minmult = src->minmult;
    dest->maxmult = src->maxmult;
    dest->updmaxmult = src->updmaxmult;
    dest->dense_fract = src->dense_fract;
    dest->dense_min = src->dense_min;
    dbl_EGlpNumCopy(dest->maxelem_orig, src->maxelem_orig);
    dest->nzcnt_orig = src->nzcnt_orig;
    dbl_EGlpNumCopy(dest->maxelem_factor, src->maxelem_factor);
    dest->nzcnt_factor = src->nzcnt_factor;
    dbl_EGlpNumCopy(dest->maxelem_cur, src->maxelem_cur);
    dest->nzcnt_cur = src->nzcnt_cur;
    dbl_EGlpNumCopy(dest->partial_cur, src->partial_cur);
    dest->dim = src->dim;
    dest->stage = src->stage;
    dest->nstages = src->nstages;
    dest->etacnt = src->etacnt;
    dest->ur_space = src->ur_space;
    dest->uc_space = src->uc_space;
    dest->lc_space = src->lc_space;
    dest->lr_space = src->lr_space;
    dest->er_space = src->er_space;
    dest->ur_freebeg = src->ur_freebeg;
    dest->uc_freebeg = src->uc_freebeg;
    dest->lc_freebeg = src->lc_freebeg;
    dest->lr_freebeg = src->lr_freebeg;
    dest->er_freebeg = src->er_freebeg;
    dest->drows = src->drows;
    dest->dcols = src->dcols;
    dest->dense_base = src->dense_base;

    // shallow copy.
    dest->p_nsing = src->p_nsing;
    dest->p_singr = src->p_singr;
    dest->p_singc = src->p_singc;



    if (src->work_coef) {
        dest->work_coef = dbl_EGlpNumAllocArray(src->dim);
        if (!dest->work_coef) { rval = 1; goto CLEANUP; }
        for (i = 0; i < src->dim; i++) {
            dbl_EGlpNumCopy(dest->work_coef[i], src->work_coef[i]);
        }
    }

    if (src->work_indx) {
        ILL_SAFE_MALLOC(dest->work_indx, src->dim, int);
        memcpy(dest->work_indx, src->work_indx, src->dim * sizeof(int));
    }
    
    // Info structs
    if (src->uc_inf) {
        ILL_SAFE_MALLOC(dest->uc_inf, src->dim + src->max_k + 1, dbl_uc_info);
        memcpy(dest->uc_inf, src->uc_inf, (src->dim + src->max_k + 1) * sizeof(dbl_uc_info));
    }
    if (src->ur_inf) {
        ILL_SAFE_MALLOC(dest->ur_inf, src->dim + src->max_k + 1, dbl_ur_info);
        memcpy(dest->ur_inf, src->ur_inf, (src->dim + src->max_k + 1) * sizeof(dbl_ur_info));
        for (i = 0; i < src->dim + src->max_k + 1; i++) {
            dbl_EGlpNumInitVar(dest->ur_inf[i].max);
            dbl_EGlpNumCopy(dest->ur_inf[i].max, src->ur_inf[i].max);
        }
    }
    if (src->lc_inf) {
        ILL_SAFE_MALLOC(dest->lc_inf, src->dim, dbl_lc_info);
        memcpy(dest->lc_inf, src->lc_inf, src->dim * sizeof(dbl_lc_info));
    }
    if (src->lr_inf) {
        ILL_SAFE_MALLOC(dest->lr_inf, src->dim, dbl_lr_info);
        memcpy(dest->lr_inf, src->lr_inf, src->dim * sizeof(dbl_lr_info));
    }
    if (src->er_inf) {
        ILL_SAFE_MALLOC(dest->er_inf, src->etamax, dbl_er_info);
        memcpy(dest->er_inf, src->er_inf, src->etamax * sizeof(dbl_er_info));
    }
	
    // U matrix data
    if (src->ucindx) {
        ILL_SAFE_MALLOC(dest->ucindx, src->uc_space + 1, int);
        memcpy(dest->ucindx, src->ucindx, (src->uc_space + 1) * sizeof(int));
    }
    if (src->ucrind) {
        ILL_SAFE_MALLOC(dest->ucrind, src->uc_space, int);
        memcpy(dest->ucrind, src->ucrind, src->uc_space * sizeof(int));
    }

    if (src->uccoef) {
        dest->uccoef = dbl_EGlpNumAllocArray(src->uc_space);
        if (!dest->uccoef) { rval = 1; goto CLEANUP; }
        for (i = 0; i < src->uc_space; i++) {
            dbl_EGlpNumCopy(dest->uccoef[i], src->uccoef[i]);
        }
    }

    if (src->urindx) {
        ILL_SAFE_MALLOC(dest->urindx, src->ur_space + 1, int);
        memcpy(dest->urindx, src->urindx, (src->ur_space + 1) * sizeof(int));
    }
    if (src->urcind) {
        ILL_SAFE_MALLOC(dest->urcind, src->ur_space, int);
        memcpy(dest->urcind, src->urcind, src->ur_space * sizeof(int));
    }
    if (src->urcoef) {
        dest->urcoef = dbl_EGlpNumAllocArray(src->ur_space);
        if (!dest->urcoef) { rval = 1; goto CLEANUP; }
        for (i = 0; i < src->ur_space; i++) {
            dbl_EGlpNumCopy(dest->urcoef[i], src->urcoef[i]);
        }
    }
	
    // L matrix data
    if (src->lcindx) {
        ILL_SAFE_MALLOC(dest->lcindx, src->lc_space, int);
        memcpy(dest->lcindx, src->lcindx, src->lc_space * sizeof(int));
    }

    if (src->lccoef) {
        dest->lccoef = dbl_EGlpNumAllocArray(src->lc_space);
        if (!dest->lccoef) { rval = 1; goto CLEANUP; }
        for (i = 0; i < src->lc_space; i++) {
            dbl_EGlpNumCopy(dest->lccoef[i], src->lccoef[i]);
        }
    }
				  
	if (src->lrindx) {
		int lr_nzcnt = 0;
		for (i = 0; i < src->dim; i++) {
			lr_nzcnt += src->lr_inf[i].nzcnt;
		}
		ILL_SAFE_MALLOC(dest->lrindx, lr_nzcnt + 1, int);
		memcpy(dest->lrindx, src->lrindx, (lr_nzcnt + 1) * sizeof(int));
	}

	if (src->lrcoef) {
		int lr_nzcnt = 0;
		for (i = 0; i < src->dim; i++) {
			lr_nzcnt += src->lr_inf[i].nzcnt;
		}
		dest->lrcoef = dbl_EGlpNumAllocArray(lr_nzcnt);
		if (!dest->lrcoef) { rval = 1; goto CLEANUP; }
		for (i = 0; i < lr_nzcnt; i++) {
			dbl_EGlpNumCopy(dest->lrcoef[i], src->lrcoef[i]);
		}
	}

    // Eta data
    if (src->erindx) {
        ILL_SAFE_MALLOC(dest->erindx, src->er_space, int);
        memcpy(dest->erindx, src->erindx, src->er_space * sizeof(int));
    }
	
    if (src->ercoef) {
        dest->ercoef = dbl_EGlpNumAllocArray(src->er_space);
        if (!dest->ercoef) { rval = 1; goto CLEANUP; }
        for (i = 0; i < src->er_space; i++) {
            dbl_EGlpNumCopy(dest->ercoef[i], src->ercoef[i]);
        }
    }

    // Permutations
    if (src->rperm) {
        ILL_SAFE_MALLOC(dest->rperm, src->dim, int);
        memcpy(dest->rperm, src->rperm, src->dim * sizeof(int));
    }
    if (src->rrank) {
        ILL_SAFE_MALLOC(dest->rrank, src->dim, int);
        memcpy(dest->rrank, src->rrank, src->dim * sizeof(int));
    }
    if (src->cperm) {
        ILL_SAFE_MALLOC(dest->cperm, src->dim, int);
        memcpy(dest->cperm, src->cperm, src->dim * sizeof(int));
    }
    if (src->crank) {
        ILL_SAFE_MALLOC(dest->crank, src->dim, int);
        memcpy(dest->crank, src->crank, src->dim * sizeof(int));
    }
    
    // Dense Matrix
    if (src->dmat) {
        dsize = src->drows * src->dcols;
        dest->dmat = dbl_EGlpNumAllocArray(dsize);
        if (!dest->dmat) { rval = 1; goto CLEANUP; }
        for (i = 0; i < dsize; i++) {
            dbl_EGlpNumCopy(dest->dmat[i], src->dmat[i]);
        }
    }

    // svector xtmp
    rval = dbl_ILLsvector_alloc(&dest->xtmp, src->dim);
    if (rval) goto CLEANUP;
    dest->xtmp.nzcnt = src->xtmp.nzcnt;
    if (src->xtmp.nzcnt > 0) {
        memcpy(dest->xtmp.indx, src->xtmp.indx, src->xtmp.nzcnt * sizeof(int));
        for (i = 0; i < src->xtmp.nzcnt; i++) {
            dbl_EGlpNumCopy(dest->xtmp.coef[i], src->xtmp.coef[i]);
        }
    }
    	
    goto FINAL;

CLEANUP:
    // If any allocation fails, FREE
	printf("Error allocating memory for factor work copy.\n");
    dbl_ILLfactor_free_factor_work(dest);

FINAL:
    return rval;
}